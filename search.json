[
  {
    "objectID": "posts/230202_hydrologimodellering/index.html",
    "href": "posts/230202_hydrologimodellering/index.html",
    "title": "Hydrologiprogrammering",
    "section": "",
    "text": "üì∑ Dettifoss, Island"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#importere-bibliotek",
    "href": "posts/230202_hydrologimodellering/index.html#importere-bibliotek",
    "title": "Hydrologiprogrammering",
    "section": "Importere bibliotek",
    "text": "Importere bibliotek\nVassf√∏ringsdataa er lasta ned i csv-format. Me bruker pandas for √• jobba med dette effektivt. I tillegg vert det litt plotting og matematikk, s√• me treng pyplot og numpy i tillegg.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#opprette-dataramme",
    "href": "posts/230202_hydrologimodellering/index.html#opprette-dataramme",
    "title": "Hydrologiprogrammering",
    "section": "Opprette dataramme",
    "text": "Opprette dataramme\nCSV-fila med vassf√∏ringsdata les me inn i ei dataramme (dataframe). Viss ein tar ein kikk p√• fila ser ein at det er brukt semikolon for √• skilja verdiane, det er to rader f√∏r verdiane kjem. Me lagar litt forenkla namn p√• kolonnene, og les inn data. I tillegg er det nytta komma (og ikkje punktum) som desimalteikn.\n\n\n\nüîç Dei f√∏rste linjene\n\n\n\ndf = pd.read_csv(\n    \"vassforing_reinsnos_dogn.csv\", \n    sep = \";\", \n    skiprows = 2, \n    names = [\"dato\", \"Vassf√∏ring\", \"Korrigert\", \"Kontrollert\"], \n    parse_dates = True, \n    decimal=\",\"\n)\n\ndf.index = pd.to_datetime(df['dato']) \ndf.index = pd.to_datetime(df.index.date)\ndf = df.drop(columns = [\"dato\", \"Korrigert\", \"Kontrollert\"])\n\nSjekkar dei nyaste fem m√•lingane i tabellen for √• sj√• at alt ser ok ut.\n\ndf.tail()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n    \n  \n  \n    \n      2023-01-24\n      1.299365\n    \n    \n      2023-01-25\n      1.593457\n    \n    \n      2023-01-26\n      2.128418\n    \n    \n      2023-01-27\n      2.322153\n    \n    \n      2023-01-28\n      2.324195\n    \n  \n\n\n\n\nI tillegg kan me pr√∏va √• plotta verdiane i dataramma.  Har med ; for √• unng√• √• visa meldinga <AxesSubplot: >\n\ndf.plot();\n\n\n\n\n\n\n\n\nMe ser her at dette ikkje er spesielt nyttig eller informativt, men grafen viser oss at det p√• 1920-talet er eit par √•r utan m√•lingar. Korleis dette kan fiksast kjem me attende til litt seinare."
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#middelflom",
    "href": "posts/230202_hydrologimodellering/index.html#middelflom",
    "title": "Hydrologiprogrammering",
    "section": "Middelflom",
    "text": "Middelflom\nMiddelflommen til ei elv er rekna ut fr√• den st√∏rste d√∏gnvassf√∏ringa per √•r over eit lengre tidsrom. Fr√• NVE/varsom.no finn me denne definisjonen:\n\nEn middelflom (normal flom) defineres som gjennomsnittet av h√∏yeste vannf√∏ring hvert √•r i en lang √•rrekke.\n\nFor √• rekna ut dette m√• me alts√• f√∏rst finna den maksimale vassf√∏ringa per √•r. Bruker groupby i Pandas for √• finne dette.\n\n√•rleg_vf_maks = df.groupby(by=[df.index.year]).max()\n√•rleg_vf_maks.head()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n    \n  \n  \n    \n      1917\n      26.98031\n    \n    \n      1918\n      50.93218\n    \n    \n      1919\n      37.72713\n    \n    \n      1920\n      63.26006\n    \n    \n      1921\n      58.04514\n    \n  \n\n\n\n\nPlottar den nye dataramma √•rleg_maks som kun har ei m√•ling per √•r:\n\n√•rleg_vf_maks.plot();\n\n\n\n\n\n\n\n\nP√• grunn av ‚Äúholet‚Äù i m√•lingane tar me berre med data fr√• 1930 eller seinare med oss vidare. I tillegg er det vinter (og sn√∏/is) for dataa me har for 2023, s√• me avgrensar til 2022.\n\n√•rleg_vf_maks = √•rleg_vf_maks.loc[1930:2022]\n√•rleg_vf_maks.head()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n    \n  \n  \n    \n      1930\n      43.82251\n    \n    \n      1931\n      46.29647\n    \n    \n      1932\n      52.52979\n    \n    \n      1933\n      68.09634\n    \n    \n      1934\n      48.32775\n    \n  \n\n\n\n\nMe vil finna gjennomsnittleg st√∏rste √•rlege vassf√∏ring over fleire √•r. Vel her √• sj√• p√• eit gjennomsnitt p√• 30 √•r om gongen. Bruker funksjonen rolling og mean i kombinasjon. rolling gjer at me kan g√• gjennom dataramma og sj√• p√• dei 30 tidlegare verdiane til kvar rad i tabellen og finna gjennomsnittet (mean) i dette rullande vinduet.\n\nmaksvf_og_middelflom = √•rleg_vf_maks.copy()\nmaksvf_og_middelflom[\"Middelflom\"] = √•rleg_vf_maks.rolling(window = 30).mean()\n\nSer p√• dei f√∏rste 5 radene\n\nmaksvf_og_middelflom.head()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n      Middelflom\n    \n  \n  \n    \n      1930\n      43.82251\n      NaN\n    \n    \n      1931\n      46.29647\n      NaN\n    \n    \n      1932\n      52.52979\n      NaN\n    \n    \n      1933\n      68.09634\n      NaN\n    \n    \n      1934\n      48.32775\n      NaN\n    \n  \n\n\n\n\nSer at dei fem f√∏rste radene i den nye dataramma er NaN (not a number). Dette skjer fordi ein ikkje kan ta gjennomsnitt av dei siste 30 √•ra f√∏r det har g√•tt 30 √•r‚Ä¶ Sjekkar dei nyaste radene i staden:\n\nmaksvf_og_middelflom.tail()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n      Middelflom\n    \n  \n  \n    \n      2018\n      73.75180\n      60.571163\n    \n    \n      2019\n      47.75206\n      59.893282\n    \n    \n      2020\n      78.19958\n      60.860965\n    \n    \n      2021\n      46.81937\n      60.837067\n    \n    \n      2022\n      73.51824\n      60.972971\n    \n  \n\n\n\n\nPlottar dataramma og ser korleis dei nye verdiane ser ut:\n\nmaksvf_og_middelflom.plot();"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#modellering-av-middelflom",
    "href": "posts/230202_hydrologimodellering/index.html#modellering-av-middelflom",
    "title": "Hydrologiprogrammering",
    "section": "Modellering av middelflom",
    "text": "Modellering av middelflom\nSer at trenden er oppadg√•ande og relativt line√¶r. √ònsker √• laga ein line√¶r modell. Bruker polyfit fr√• NumPy.\n\n# √•ra me har data p√• middelflom\n# fr√• og med 1959 til men ikkje med 2023\nx = np.arange(1959, 2023) \n\n# finn koeffesientane til f√∏rstegradspolynomet\na, b = np.polyfit(x, maksvf_og_middelflom[\"Middelflom\"].loc[1959:2022], 1)\n\n# definerer line√¶r funksjon\ndef f(x):\n    return a*x + b\n\n# plottar dataramma\nmaksvf_og_middelflom.plot(\n    figsize = (20,9), \n    grid = True, \n    fontsize = 16, \n    linewidth = 3, \n    color = [\"lightsteelblue\", \"royalblue\"]\n)\n\n# plottar modellen\nplt.plot(\n    x, f(x), \n    linewidth = 2, \n    label = \"Modell for middelflom\", \n    color = \"red\"\n)\n\n# pynting av plot\nplt.title(\"Vassf√∏ring og middelflom\\n\", fontsize = 24)\nplt.legend(fontsize = 16)\nplt.ylabel(\"Vassf√∏ring, kubikkmeter/s\", fontsize = 16)\nplt.xlabel(\"√Ör\", fontsize = 16)\n#plt.savefig(\"Reinsnos - √•rleg maksvassf√∏ring og middelflom.png\", dpi = 300)\nplt.show()\n\n\n\n\n\n\n\n\nEkstrapolasjon - modell for framtidig middelflom\nMe kan bruka trendlinja for middelflommen som modell for √• seie noko om korleis utviklinga vil vera i √•ra framover (om utviklinga held fram som no):\n\n\nKode\nmaksvf_og_middelflom.plot(figsize = (20,9), \n                grid = True, \n                fontsize = 16, \n                linewidth = 3, \n                color = [\"lightsteelblue\", \"royalblue\"]\n               )\n\nplt.plot(x, f(x), \n         linewidth = 1.5, \n         label = \"Modell - middelflom\", \n         color = \"crimson\"\n        )\n\n# Plottar forlenginga av den line√¶re modellen\nx2 = np.arange(2022, 2101)\nplt.plot(x2, f(x2), \":\", linewidth = 3, color = \"crimson\")\n\n# pynting av plot\nplt.title(\"Vassf√∏ring og middelflom - modell fram mot 2100 \\n\", fontsize = 24)\nplt.legend(fontsize = 16)\nplt.ylabel(\"Vassf√∏ring, kubikkmeter/s\", fontsize = 16)\nplt.xlabel(\"√Ör\", fontsize = 16)\n#plt.savefig(\"Reinsnos - modellering av middelflom 2100.png\", dpi = 300)\nplt.show()"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#sjekkar-opp-mot-nve-sine-flom-data",
    "href": "posts/230202_hydrologimodellering/index.html#sjekkar-opp-mot-nve-sine-flom-data",
    "title": "Hydrologiprogrammering",
    "section": "Sjekkar opp mot NVE sine flom-data",
    "text": "Sjekkar opp mot NVE sine flom-data\nFr√• stasjonsssida til Reinsnosvatn kan me finna data om ulike typar flom.\n\n\n\nFlomdata fr√• NVE\n\n\nSer at verdien for 20-√•rsflom er 78,28 \\(m^3/s\\). Plottar inn linja \\(y=78,28\\) i samme figur som tidlegare. Bruker plt.axhline() for √• teikna horisontal linje.\n\n\nKode\n# √•ra me har data p√• middelflom\n# fr√• og med 1959 til men ikkje med 2023\nx = np.arange(1959, 2023) \n\n# finn koeffesientane til f√∏rstegradspolynomet\na, b = np.polyfit(x, maksvf_og_middelflom[\"Middelflom\"].loc[1959:2022], 1)\n\n# definerer line√¶r funksjon\ndef f(x):\n    return a*x + b\n\n# plottar dataramma\nmaksvf_og_middelflom.plot(\n    figsize = (20,9), \n    grid = True, \n    fontsize = 16, \n    linewidth = 3, \n    color = [\"lightsteelblue\", \"royalblue\"]\n)\n\n# plottar modellen\nplt.plot(\n    x, f(x), \n    linewidth = 2, \n    label = \"Modell for middelflom\", \n    color = \"red\"\n)\n\n# plottar 20-√•rsflom\nplt.axhline(\n        y = 78.28,\n        color = \"crimson\", \n        linewidth = 3, \n        linestyle = \":\", \n        label = \"20-√•rsflom\"\n)\n\n# pynting av plot\nplt.title(\"Vassf√∏ring og middelflom\\n\", fontsize = 24)\nplt.legend(fontsize = 16)\nplt.ylabel(\"Vassf√∏ring, kubikkmeter/s\", fontsize = 16)\nplt.xlabel(\"√Ör\", fontsize = 16)\n#plt.savefig(\"Reinsnos - √•rleg maksvassf√∏ring og middelflom.png\", dpi = 300)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips til oppg√•ver\n\n\n\nPlott linjer for dei ulike flom-typane. Kor godt stemmer observasjonane med desse tala?  Kva ligg i omgrepet 20-√•rsflom?"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#utrekningar",
    "href": "posts/230202_hydrologimodellering/index.html#utrekningar",
    "title": "Hydrologiprogrammering",
    "section": "Utrekningar",
    "text": "Utrekningar\nFinn ulike verdiar per dag i √•ret over dei 104 √•ra.\n\npiv[\"min\"] = piv.min(axis = 1)\npiv[\"maks\"] = piv.max(axis = 1)\npiv[\"75%\"] = piv.quantile(q = 0.75,axis = 1)\npiv[\"median\"] = piv.median(axis = 1)\npiv[\"25%\"] = piv.quantile(q = 0.25,axis = 1)\n\npiv.head()\n\n\n\n\n\n  \n    \n      \n      Vassf√∏ring\n      min\n      maks\n      75%\n      median\n      25%\n    \n    \n      √•r\n      1917\n      1918\n      1919\n      1920\n      1921\n      1922\n      1923\n      1924\n      1925\n      1929\n      ...\n      2019\n      2020\n      2021\n      2022\n      2023\n      \n      \n      \n      \n      \n    \n    \n      doy\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1\n      NaN\n      0.751369\n      0.520992\n      0.110245\n      0.520992\n      2.268141\n      0.858653\n      NaN\n      4.303123\n      NaN\n      ...\n      2.347107\n      12.096400\n      2.466642\n      4.124214\n      2.000038\n      0.110245\n      28.48319\n      2.589138\n      1.381706\n      0.701046\n    \n    \n      2\n      NaN\n      0.751369\n      0.481094\n      0.095431\n      0.562897\n      2.268141\n      0.751369\n      NaN\n      4.003652\n      NaN\n      ...\n      2.669421\n      8.641389\n      2.288357\n      5.344579\n      1.913351\n      0.095431\n      19.01132\n      2.548025\n      1.417153\n      0.652886\n    \n    \n      3\n      NaN\n      0.701046\n      0.443164\n      0.095431\n      0.606849\n      2.166990\n      0.803893\n      NaN\n      3.858951\n      NaN\n      ...\n      2.515568\n      8.580434\n      2.122319\n      6.083396\n      1.827513\n      0.095431\n      11.99520\n      2.491543\n      1.381060\n      0.606849\n    \n    \n      4\n      NaN\n      0.701046\n      0.407161\n      0.095431\n      0.652886\n      1.973261\n      0.915689\n      NaN\n      3.717565\n      NaN\n      ...\n      2.336836\n      7.108252\n      1.954245\n      5.640584\n      1.779285\n      0.095431\n      14.41007\n      2.421806\n      1.275205\n      0.652886\n    \n    \n      5\n      NaN\n      0.652886\n      0.373045\n      0.110245\n      0.803893\n      1.703600\n      0.915689\n      NaN\n      3.444615\n      NaN\n      ...\n      2.265773\n      5.907576\n      1.806864\n      4.668677\n      1.701279\n      0.110245\n      18.95604\n      2.372195\n      1.207931\n      0.728653\n    \n  \n\n5 rows √ó 109 columns"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#plottar",
    "href": "posts/230202_hydrologimodellering/index.html#plottar",
    "title": "Hydrologiprogrammering",
    "section": "Plottar",
    "text": "Plottar\n\n# Plottar minimumsverdiar\npiv[\"min\"].plot(\n    figsize = (20, 8),\n    color = \"seagreen\", \n    linewidth = 0.8, \n    grid = False, \n    fontsize = 18, \n    legend = False,\n    label = \"Minste verdi\"\n)\n\n# PLottar maksimumsverdiar\npiv[\"maks\"].plot(\n    color = \"seagreen\", \n    linewidth = 0.8, \n    grid = False, \n    fontsize = 18, \n    legend = False,\n    label = \"St√∏rste verdi\"\n)\n\n# Fargelegg omr√•det mellom 25- og 75-persentilane\nplt.fill_between(\n    piv.index, \n    piv[\"25%\"], piv[\"75%\"], \n    facecolor='green', \n    alpha=0.2, \n    interpolate=True,\n    label = \"25% - 75%\"\n)\n\n# Plottar medianen\npiv[\"median\"].plot(\n    linewidth = 2, \n    color = \"darkgreen\",\n    label = \"Median\"\n)\n\n# Pyntar p√• plottet\nplt.xlabel(\"Dag i √•ret \\n (01. jan - 31. des)\", fontsize = 18)\nplt.ylabel(\"Vassf√∏ring i $m^3/s$\", fontsize = 18)\nplt.title(\"Vassf√∏ring - per dag i √•ret \\n\", fontsize = 24)\nplt.legend(fontsize = 16)\nplt.savefig(\"Reinsnos - vassf√∏ring per dag gjennom √•ret.png\", dpi = 300)\nplt.show()"
  },
  {
    "objectID": "posts/230202_hydrologimodellering/index.html#oppsummert",
    "href": "posts/230202_hydrologimodellering/index.html#oppsummert",
    "title": "Hydrologiprogrammering",
    "section": "Oppsummert",
    "text": "Oppsummert\nDet er mykje kjekt ein kan gjera med vassf√∏ringsdata fr√• NVE. B√•de det √• laga plott som me har gjort over, og arbeida med store datamengder som dette kan erfaringsmessig gje elevane god innsikt i samanhengar og forst√•ing for omgrep i hydrologien.\n\n\n\n\n\n\nTips til undervisinga\n\n\n\nDei elevlaga hydrogramma er eit godt utganspunkt for diskusjonar og utforsking.\n1Ô∏è‚É£ Jobb med koden saman med elevane. Lag plotta.  2Ô∏è‚É£ Be elevane om √• finna andre elver (ulik storleik, ulik geografisk plassering) og lage eigne plott.  3Ô∏è‚É£ Sj√• p√• ulike hydrogram laga av elevane (utan namn p√• vassdraget) og ha diskusjon i klassen om kva informasjon som ligg i plotta (Nord/s√∏r/aust/vest? H√∏gde? Isbre? Sn√∏smelting/regnflom? Regulering?)  4Ô∏è‚É£ Avsl√∏r namn og plassering - korleis stemte det?"
  },
  {
    "objectID": "posts/230127_zotero/index.html",
    "href": "posts/230127_zotero/index.html",
    "title": "Zotero - kva, kvifor, korleis?",
    "section": "",
    "text": "Zotero er eit verkt√∏y for √• handtera kjelder og siteringar. Det er relativt enkelt √• bruka, og kan nyttast p√• tvers av ulike platformar og programvare. Terskelen for √• implementera Zotero i undervisinga kan kanskje opplevast som litt h√∏g. S√• her kjem eit par argument for kvifor det kan vera ein fordel √• ta dette steget, samt eit par konkrete tips og triks üöÄ"
  },
  {
    "objectID": "posts/230127_zotero/index.html#organisere-biblioteket",
    "href": "posts/230127_zotero/index.html#organisere-biblioteket",
    "title": "Zotero - kva, kvifor, korleis?",
    "section": "Organisere biblioteket",
    "text": "Organisere biblioteket\nN√•r du har lasta ned Zotero startar du med eit tomt bibliotek. Dette kan du organisera i samlingar (mapper). Du lager nye samlingar med √• trykka p√• knappen til venstre over Mitt bibliotek\n\n\n\nOrganisere biblioteket\n\n\nHer kan ein t.d. dela inn etter fag, etter √•rstrinn eller andre inndelingar slik ein √∏nsker. Det er mogleg √• ha under-samlingar viss ein √∏nsker det."
  },
  {
    "objectID": "posts/230127_zotero/index.html#legge-til-kjelder",
    "href": "posts/230127_zotero/index.html#legge-til-kjelder",
    "title": "Zotero - kva, kvifor, korleis?",
    "section": "Legge til kjelder",
    "text": "Legge til kjelder\nN√•r ein skal fylla biblioteket sitt gjer ein dette p√• fleire ulike m√•tar. Her vil eg demonstrera korleis ein gjer det\n\nmanuelt\nmed Zotero Connector\nmagisk üßô\n\nLegge til manuelt\n\n\n\n\n\nFor √• legga til kjelder trykker ein p√• det gr√∏ne pluss-teiknet og vel ein passande type (t.d. bok). N√•r ein har gjort dette f√•r ein opp ei kolonne til h√∏gre med ulike felt som m√• fyllast ut:\n\n\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nP√• sidene til kjeldekompasset finn ein informasjon om kva felt som m√• fyllast ut.  Her er eit d√∏me p√• kapittel i bok med redakt√∏r (i APA7-stil)\n\n\nMed Zotero Connector\nZotero Connector er ein plugin til nettlesar som gjer at ein automatisk kan legga kjelder p√• nett inn i biblioteket sitt. Her kan ein ta med snapshot av nettsida ein bes√∏ker, eller lasta ned pdf-dokumentet ein er inne p√•. Ein kan √≤g velga kva for samling i biblioteket den aktuelle ressursen skal lagrast til\n\n\n\n\n\n\n\n\n\n\n\nPass p√•\n\n\n\nDet er ikkje alltid at alle felt vert rett fylt ut i Zotero, s√• dette m√• dobbelsjekkast (gjerne opp mot kildekompasset)\n\n\nMagisk\nNokre kjelder som b√∏ker og forskingsartiklarkan leggast inn ved hjelp av identifikatorar som ISBN, DOI, PMID osb. D√• trykker ein p√• tryllestav-knappen til h√∏gre for den vanlege ‚Äúlegg til‚Äù-knappen. For ein del norske b√∏ker fungerer dette ofte ikkje, men for forskingsartiklar med DOI passar det godt."
  },
  {
    "objectID": "posts/230127_zotero/index.html#sitere-i-tekstbehandlar",
    "href": "posts/230127_zotero/index.html#sitere-i-tekstbehandlar",
    "title": "Zotero - kva, kvifor, korleis?",
    "section": "Sitere i tekstbehandlar",
    "text": "Sitere i tekstbehandlar\nI Microsoft Word og Google Docs er det eigne Zotero-verkt√∏y. N√•r du har lasta ned og innstallert Zotero vil du sj√• dette neste gong du opnar Word.\n\n\n\n\n\nHer ligg det verkt√∏y for √• legga inn referansar i tekst og kjeldeliste/bibliografi til slutt. For √• legge inn referanse i teksten trykker ein p√• Add/Edit Citation og s√∏ker etter kjelda i s√∏kefeltet. F√∏rste gang blir du bedt om √• velga siteringsstil. Eg nyttar vanlegvis APA7 (American Psychological Association).\n\n\n\n\n\nOm du vil inkludera sidetal, kan du klikka p√• den valgte kjelda og legga inn dette manuelt. D√• vil Zotero automatisk formatera referansen i teksten p√• rett m√•te (og p√• rett spr√•k).\n\n\n\n\n\nTil slutt kan du laga kjeldeliste av dei kjeldene som er nytta i teksten med √• trykka p√• Add/Edit Bibliography. Denne vert automatisk sortert og formatert etter valgt referansestil."
  },
  {
    "objectID": "posts/230127_zotero/index.html#sitere-utanfor-tekstbehandlar",
    "href": "posts/230127_zotero/index.html#sitere-utanfor-tekstbehandlar",
    "title": "Zotero - kva, kvifor, korleis?",
    "section": "Sitere utanfor tekstbehandlar",
    "text": "Sitere utanfor tekstbehandlar\nI presentasjonsverkt√∏y som PowerPoint har ein ikkje innebygde Zotero-verkt√∏y. Likevel er Zotero til god hjelp. Ein m√•te ein kan halda oversikt over kva kjelder ein har nytta i eit aktuelt prosjekt er gjennom √• legga til emneord til dei ulike kjeldene. Til d√∏mes blogg-zotero. D√• kan ein s√∏ka og filtrera biblioteket sitt etter det spesifikke emneordet. Vidare kan ein d√• kopiera henvising (shift+cmd/windows+A) av den valgte kjelda. Ein kan til slutt markera alle kjeldene og kopiera bibliografi (shift+cmd/windows+C)."
  },
  {
    "objectID": "posts/230209_simulering1/index.html",
    "href": "posts/230209_simulering1/index.html",
    "title": "Grunnleggjande simulering i NumPy",
    "section": "",
    "text": "Simulering er ein viktig del av l√¶replanen i matematikk for samfunnsfag (S1 + S2) i LK20. Mange l√¶reb√∏ker er opptatt av l√∏kker i simuleringa si. Det tar tid √• k√∏yra, kan vera meir tungt for elevane √• forst√• og kan by p√• meir feilmeldingar mtp. syntaks. Her kjem eit (kanskje av fleire) innlegg med tips til simulering med NumPy.\n\n\nFor √• simulera lagar me ein random generator. Denne kallar me for rng (random number generator). Me kan tilpassa default_rng() med √• gje han ulike argument (feks. seed for √• f√• reproduserbare tal) men i praksis i S1 og S2 er det ikkje noko me treng √• tenka p√•.\n\nimport numpy as np\nrng = np.random.default_rng()\n\nDenne generatoren kan me bruka til mange ulike simuleringar. Om me vil kasta ein terning ein gong kan me trekka eit heiltal. Det gjer me med funksjonen integers(low, high) som ligg i rng-en v√•r.\n\nterning = rng.integers(1, 7)\nprint(terning)\n\n3\n\n\n\n\n\n\n\n\nPass p√•\n\n\n\nHer vil terning = rng.integers(1, 7) gje oss\n\\[\\text{terning} \\in \\{1, 2, 3, 4, 5, 6\\}\\]\nMed andre ord \\[1 \\leq \\text{terning} < 7\\]\n\n\nOm me vil kasta fleire terningar kan me i tillegg gje inn size som argument til rng.integers\n\nterningar = rng.integers(1, 7, 10)\nprint(terningar)\n\n[1 1 4 2 5 1 6 5 3 5]\n\n\nVidare kan me rekna med resultata. Desse er lagra i ein array (ein variabeltype som minnar om lister).\nMe kan t.d. sjekka kor mange av dei 10 terningane me kasta som vart seksarar. F√∏rst kan me sjekka kva verdiar som er 6:\n\nterningar == 6\n\narray([False, False, False, False, False, False,  True, False, False,\n       False])\n\n\nDette kan me bruka til √• rekna med. Sidan False vert tolka som 0 og True vert tolka som 1 kan me finna summen av arrayen med sanningsvariablane:\n\nsum(terningar == 6)\n\n1\n\n\n\n\n\nMe trillar terning.\n\\(A\\): terningen viser 5 eller 6.\nFinn \\(P(A)\\) ved hjelp av simulering.\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# tal simuleringar\nN = 10000000\n\n# triller terning N gongar\nterningar = rng.integers(1, 7, N)\n\n# finn antall femmarar og seksarar\ngunstige = sum(terningar >= 5)\n\n# finn og skriv ut relativ frekvens\nrel_frek = gunstige / N\nprint(f\"P(A) = {rel_frek:.4f}\")\n\nP(A) = 0.3332\n\n\nUt fr√• 10 000 000 simuleringar ser me at \\(P(A)=0,3333\\). Dvs. det er \\(33,33\\%\\) sannsynleg √• trilla 5 eller 6 p√• terningen.\nD√∏met over er eit problem som ikkje er vanskeleg √• l√∏ysa analytisk, og dermed ikkje veldig spennande √• bruka simulering p√•. Men om problema vert vanskelege √• rekna p√• er dei ofte ikkje s√• vanskelege √• simulera. Eit litt meir avansert problem (som er lett √• simulera) finn me i S1-eksamen fr√• v√•ren 2022:\n\nI eit spel kastar du tre terningar. Du multipliserer saman augetalet p√• terningane. Dersom dette produktet er st√∏rre enn 100, vinn du. Bestem sannsynet for √• vinne ved √• k√∏yre simuleringar. Hugs √• vise korleis du kjem fram til svaret. UDIR (2022) - Eksamen S1-V22\n\nFor √• svare p√• denne oppg√•va treng me litt meir kjennskap til korleis me kan jobba med arrays. Arrays er ein form for lister eller vektorar. Me kan utf√∏ra ulike rekneoperasjonar med dei. Me kan t.d. legga dei saman og multiplisera dei:\n\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.array([6, 5, 4, 3, 2, 1])\n\nprint(a+b)\nprint(a*b)\n\n[7 7 7 7 7 7]\n[ 6 10 12 12 10  6]\n\n\nD√• har me alt me treng for √• l√∏ysa eksamensoppg√•va:\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# antall simuleringar\nN = 1000000\n\n# triller 3 terningar N gongar\nt1 = rng.integers(1, 7, N)\nt2 = rng.integers(1, 7, N)\nt3 = rng.integers(1, 7, N)\n\n# finn produktet\nprod = t1* t2 * t3\n\n# tel opp kor mange av produkta som er over 100\ngunstige = sum(prod > 100)\n\n# finn og skriv ut relativ frekvens\nrel_frek = gunstige / N\nprint(f\"P(produkt over 100) = {rel_frek:.4f}\")\n\nP(produkt over 100) = 0.0928\n\n\nDet er med andre ord ca. \\(9,34\\%\\) sannsynleg √• vinna spelet."
  },
  {
    "objectID": "posts/230209_simulering1/index.html#d√∏me-p√•-bruk",
    "href": "posts/230209_simulering1/index.html#d√∏me-p√•-bruk",
    "title": "Grunnleggjande simulering i NumPy",
    "section": "D√∏me p√• bruk",
    "text": "D√∏me p√• bruk\nMe plantar 150 fr√∏. Sannsynet for at eit fr√∏ spirer er 85%.\nKva er sannsynet for at minst 130 fr√∏ spirer?\n\\(X\\): antall fr√∏ som spirer.\n\nimport numpy as np\nrng = np.random.default_rng()\n\nN = 1000000     # antall simuleringar\n\nn = 150         # antall delfors√∏k/fr√∏\np = 0.85        # sannsynet for at eitt fr√∏ spirer\n\n# ser kor mange av fr√∏a som spirer kvar simulering\nspirer = rng.binomial(n, p, N)\n\n# tell opp dei simuleringane som gjev 130+ fr√∏ som spirer\ngunstige = sum(spirer >= 130)\n\nrel_frek = gunstige / N\nprint(f\"P(X >= 130) = {rel_frek:.4f}\")\n\nP(X >= 130) = 0.3311\n\n\nSer at \\(P(X\\geq 130) = 0,3321\\)."
  },
  {
    "objectID": "posts/230209_simulering1/index.html#d√∏me-p√•-bruk-1",
    "href": "posts/230209_simulering1/index.html#d√∏me-p√•-bruk-1",
    "title": "Grunnleggjande simulering i NumPy",
    "section": "D√∏me p√• bruk",
    "text": "D√∏me p√• bruk\nDet ligg 4 daim og 7 banantwist i ei sk√•l. Du trekk 3 bitar. Kva er sannsynet for at akkurat to av desse er daim?\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# antall simuleringar\nN = 1000000\n\nngood = 4      # daim i populasjonen\nnbad = 7       # banan i populasjonen\nnsample = 3    # antall bitar me trekk\n\n# simulerer\ntwist = rng.hypergeometric(ngood, nbad, nsample, size=N)\n\n# tel opp kor mange gonagar me fekk 2 daim\ngunstige = sum(twist == 2)\n\nrel_frek = gunstige / N\nprint(f\"P(X=2) = {rel_frek:.4f}\")\n\nP(X=2) = 0.2539\n\n\nDet er \\(25,5\\%\\) sannsynleg at det er akkurat to daimtwist."
  },
  {
    "objectID": "posts/lf/S1-H22/index.html",
    "href": "posts/lf/S1-H22/index.html",
    "title": "Eksamen H22 S1",
    "section": "",
    "text": "Her er eit forslag til l√∏ysing av hausteksamen i S1 2022. I del 2 er oppg√•vene stort sett l√∏yst i Python eller CAS.\nEg kan ikkje lova at l√∏ysinga er feilfri‚Ä¶ üòä Gje meg gjerne ein lyd om du ser feil.\n\nMiniatyrbilete: Exam icons created by Freepik - Flaticon\nEksamenssettet finn du hos UDIR: Finn eksamensoppgaver\n\n\n\n\nSkriv s√• enkelt som r√•d\n\\[ \\begin{align*}\n\\left(2a^{-2}b\\right)^{-1} \\cdot \\left(\\frac{b^2}{a}\\right)^2 &= \\frac{a^2}{2b} \\cdot \\left(\\frac{b^2}{a}\\right)^2 \\\\\n&= \\frac{a^2}{2b} \\cdot \\frac{b^4}{a^2} \\\\\n&= \\frac{b^3}{2}\n\\end{align*}\\]\n\n\n\nFunksjonen \\(O\\) gitt ved \\[O(x)=‚àí0,05x^2 +100x‚àí10 000\\] er ein god modell for overskotet i kroner som ei bedrift har kvar veke, dersom ho produserer og sel \\(x\\) einingar av ei vare.\na) Bestem \\(O'(500)\\). Gi ei tolking av svaret i denne situasjonen\nDeriverer \\(O\\) og finn \\[ O'(x)=-0,1x+100 \\] Dermed er \\[O'(500)=-0,1 \\cdot 500 + 100 = 50\\]\nDette betyr at om ein aukar produksjonen (\\(x\\)) med ei vare, s√• vil overskotet auka med ca. 50 kr.\nb) Kva er det maksimale overskotet denne bedrifta kan ha kvar veke?\nL√∏yser likninga \\(O'(x)=0\\) \\[\\begin{align*} -0,1x+100&=0 \\\\ 0,1x &= 100 \\\\ x &= 1000 \\end{align*} \\]\nDette betyr at overskotet er st√∏rst (\\(O(x)\\) er ein konkav andregradsfunksjon \\(\\Rightarrow\\) toppunkt) n√•r det vert produsert 1000 einingar. Finn overskotet:\n\\[\\begin{align*} O(1000)&=-0,05\\cdot 1000^2 + 100\\cdot 1000 - 10 000 \\\\  &= -50000+100000-10000 \\\\ &= 40000 \\end{align*}\\]\nDet st√∏rste overskotet kvar veke er 40 000 kr.\n\n\n\nL√∏ys likninga \\[ \\begin{align*}\n\\lg(x-3)+\\lg(x) &= 1 \\\\\n\\lg((x-3)x) &= 1 \\qquad \\leftarrow  \\lg(a) + \\lg(b) = \\lg(ab) \\\\\n(x-3)x &= 10^1 \\\\\nx^2 -3x - 10 &= 0 \\\\\n(x+2)(x-5) &= 0 \\qquad \\leftarrow 2-5 = -3 \\text{ og } 2\\cdot -5 = -10 \\\\\nx=-2 &\\vee x = 5\n\\end{align*} \\]\nMen kun \\(x=5\\) er gyldig l√∏ysing, pga. \\(\\lg(x)\\) i den opphavlege likninga.\n\n\n\nBestem grenseverdien \\[\\lim_{h\\rightarrow 0} \\frac{\\left(4+h\\right)^2-4^2}{h}\\]\nDenne kan l√∏ysast ved grenserekning (faktorisering eller L‚ÄôH√¥pital) men‚Ä¶\nSer av uttrykket at dette er definisjonen av den deriverte til \\(x^2\\) n√•r \\(x=4\\). Dermed f√•r me \\[\\begin{align*}\nf(x)&=x^2 \\\\ f'(x) &= 2x \\\\ f'(4) &= 2\\cdot 4 = 8 \\end{align*} \\]\n\n\n\nI ei krukke er det 2 kvite og 6 svarte kuler. Du skal tilfeldig trekkje 2 kuler utan tilbakelegging.\na) Bestem sannsynet for at minst √©i av kulene er kvit.\nTrekk 2 kuler. Utfalla me kan f√• er SS, SK, KS, KK. Viss me lar \\(X\\) vera tal kvite kuler trekt har me d√•\n\\[P(X\\geq 1) = 1 - P(X=0)\\]\nder \\[P(X=0) = \\frac{6}{8}\\cdot\\frac{5}{7}=\\frac{30}{56}=\\frac{15}{28}\\]\ndermed f√•r me \\[P(X\\geq 1)= 1 - \\frac{15}{28} = \\frac{13}{28}\\]\nI ei anna krukke ligg det eit ukjent tal kuler. Her er 2 av kulene kvite, mens resten av kulene er svarte. Du skal tilfeldig trekkje 2 kuler utan tilbakelegging. Du √∏nskjer at sannsynet for at du trekkjer 2 svarte kuler, skal v√¶re minst 50 prosent.\nb) Lag ein algoritme som du kan bruke for √• bestemme det minste talet p√• svarte kuler som det da m√• vere i krukka. Ta med n√∏dvendige formlar som du m√• bruke for √• f√∏lgje algoritmen.\nLa \\(s\\) vera talet svarte kuler og \\(k\\) talet kvite kuler.\n\n\\(k=2\\) og \\(s=2\\) (sidan me m√• minst ha to svarte kuler i krukka) \nfinn sannsynet for √• trekka 2 svarte kuler \\(P(\\text{to svarte}) = \\frac{s}{s+k}\\cdot\\frac{s-1}{s-1+k}\\)\nViss \\(P(\\text{to svarte}) <50%\\) legg til ei svart kule og gjenta 2 og 3. Viss ikkje - g√• til 4. \n\\(s\\) er no det minste talet svarte kuler.\n\n\n\n\n\n\n\n\nUnders√∏kingar viser at 70 prosent av kundane til ein butikk er turistar. Ein dag hadde butikken til saman 145 kundar. Legg n√∏dvendige f√∏resetnader til grunn, og bestem sannsynet for at minst 100 av desse kundane var turistar.\n\nHer er det naturleg √• legga til grunn at - sannsynet for at kvar kunde som kjem er turist eller ikkje er likt for alle kundane (70%) - Om ein kunde er turist eller ikkje er uavhengig om neste kunde er turist eller ikkje\n\\(T\\): kunden er turist\nDermed har me ein situasjon med - delfors√∏k med to utfall (\\(T\\) eller \\(\\bar{T}\\)) - likt sannsyn i alle delfors√∏ka (\\(P(T)=0,7\\) og \\(P(\\bar{T})=1-0,7=0,3\\)) - uavhengige delfors√∏k\nDette er ganske forenkla og i r√∏ynda vil nok ikkje dette vera uavhengige delfors√∏k, sidan turistar ofte opptrer i flokk üòÑ\nBruker f√∏rst simulering for √• bestemma sannsynet. Sjekkar opp mot sannsynskalkulatoren i GeoGebra etterp√•.\n\n\n\n\n\n\nTips\n\n\n\nTa gjerne ein kikk p√• dette innlegget om du treng meir info om grunnleggande simulering med NumPy\n\n\n\nimport numpy as np\nrng = np.random.default_rng()\n\nN = 1000000 # tal simuleringar\n\nn = 145     # tal kundar\np = 0.7     # sannsyn for turist\n\n# trekk kundar\nkundar = rng.binomial(n=n, p=p, size=N)\n\n# finn sannsynet\ngunstige = sum(kundar >= 100)\nsannsyn = gunstige / N\n\nprint(f\"Sannsynet for at det var minst 100 turistar innom er {sannsyn:.4f}\")\n\nSannsynet for at det var minst 100 turistar innom er 0.6454\n\n\nI GeoGebra\nSer at svaret vert det samme i GG:\n\n\n\nüì∑ Sannsynskalkulatoren i GeoGebra Classic 6\n\n\n\n\n\nHar f√•tt oppgitt funksjonen\n\\[f(x)=1-x^2, \\qquad D_f=[0, 1]\\]\nLa \\(a\\in\\langle 0, 1\\rangle\\) og \\(O\\) v√¶re origo. Tangenten til grafen til \\(f\\) i punktet \\(P(a, f(a))\\) skjer \\(x\\)-aksen i punktet \\(A\\) og \\(y\\)-aksen i punktet \\(B\\).\n\nBestem arealet av \\(\\triangle OAB\\) n√•r \\(P\\left(\\frac{1}{2}, \\frac{3}{4}\\right)\\)\n\nBruker CAS og finn arealet av trekanten\n\n\n\nüì∑ Skjermbilete fr√• CAS\n\n\nArealet av trekanten er \\(\\frac{25}{32}\\)\n\nBestem det minste arealet \\(\\triangle OAB\\) kan ha\n\nGjer det samme som i (a) men med \\(a\\) som \\(x\\)-verdien til tangeringspunktet. Finn ein funksjon for arealet, og finn ekstremalpunktet til denne. Viser ved andrederiverttesten at det er eit botnpunkt.\n\n\n\nüì∑ Skjermbilete fr√• CAS\n\n\nDet minste arealet trekanten kan ha er \\(\\frac{4}{9}\\sqrt{3}\\)\n\n\n\n\nTabellen nedanfor viser verdien av den totale vareeksporten fr√• Noreg for nokre √•r i perioden 1980‚Äì2018.\n\nOppg√•va ber f√∏rst om to ulike modellar ein kan bruka for √• seie noko om framtida. Det er litt krevjande med s√• f√• datapunkt og lite kunnskap om kva faktorar som spelar inn her.\nPr√∏ver heller √• finna modellar som kan passa til dei datapunkta me har.\nStartar med √• legga inn punkta og plotta dei for √• f√• oversikt.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [0, 10, 20, 30, 38]                 # √•r etter 1980\nv = [91.7, 211.6, 529.8, 788.1, 1000.3] # verdi i mrd. kr.append\n\nplt.plot(x, v, \"ro\")\nplt.show()\n\n\n\n\n\n\n\n\nLagar ein line√¶r funksjon f√∏rst.\n\na_lin, b_lin = np.polyfit(x, v, 1)\nx_verdier = np.linspace(0, 40, 1000)\n\ndef lin(x):\n    return a_lin*x + b_lin\n\nplt.plot(x, v, \"ro\")\nplt.plot(x_verdier, lin(x_verdier))\nplt.show()\n\n# Skriv ut funksjoneuttrykket\nprint(f\"f_lin(x) = {a_lin:.2f}x + {b_lin:.2f}\")\n\n\n\n\n\n\n\n\nf_lin(x) = 24.90x + 36.32\n\n\nPr√∏ver vidare √• laga ein eksponentialfunksjon p√• forma \\(g(x) = a\\cdot b^x\\) for √• sj√• om det kan passa med prosentvis auke.\n\nfrom scipy.optimize import curve_fit\n\ndef eksp(x, a, b):\n    return a * b**x\n\n# finn passande funksjon\nK, E = curve_fit(eksp, x, v)\na_eksp, b_eksp = K\n\nplt.plot(x, v, \"ro\")\nplt.plot(x_verdier, eksp(x_verdier, a_eksp, b_eksp))\nplt.show()\n\n# Skriv ut funksjoneuttrykket\nprint(f\"f_eksp(x) = {a_eksp:.2f} + {b_eksp:.2f}^x\")\n\n\n\n\n\n\n\n\nf_eksp(x) = 173.29 + 1.05^x\n\n\nPlottar begge modellane med datapunkta i samme figur for √• samanlikna.\n\nplt.plot(x, v, \"ko\")\nplt.plot(x_verdier, lin(x_verdier), \"r\", label=\"f_lin\")\nplt.plot(x_verdier, eksp(x_verdier, a_eksp, b_eksp), \"b\", label=\"f_eksp\")\n\nplt.xlabel(\"√Ör etter 1980\")\nplt.ylabel(\"Verdi vareeksport i mrd. kr.\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nDet ser ut som om den line√¶re funksjonen passar best. Kallar denne for \\(g\\). \\[ g(x) = 24.90x + 36.32\\]\nVidare er me ute etter den gjennomsnittlege √•rlege veksten mellom 2015 og 2025 for dei to modellane.\n\nsnitt_lin = (lin(45)-lin(35))/10\nsnitt_eksp = (eksp(45, a_eksp, b_eksp)-eksp(35, a_eksp, b_eksp))/10\n\nprint(f\"snitt lin:  {snitt_lin:.2f} mrd.kr. pr. √•r\\nsnitt eksp: {snitt_eksp:.2f} mrd.kr. pr. √•r\")\n\nsnitt lin:  24.90 mrd.kr. pr. √•r\nsnitt eksp: 55.35 mrd.kr. pr. √•r\n\n\n\nFunksjonen \\(f\\) gitt ved \\[f(x)=91\\cdot 1,057^x\\] er ein modell for verdien av den totale vareimporten til Noreg i milliardar kroner, \\(x\\) √•r etter 1980 . N√•r vil verdien av vareimporten til Noreg vere 10 gonger st√∏rre enn det han var i 1980?\n\nHer m√• me l√∏ysa likninga \\[1,057^x = 10\\]\nBruker CAS i Python üòé\n\nfrom sympy import *\nx = Symbol(\"x\")\n\n# definerer likning (vs, hs) og l√∏yser\neq = Eq(1.057**x, 10)\nl√∏ysing = solve(eq)\n\nprint(f\"x = {l√∏ysing[0]:.2f}\")\n\nx = 41.54\n\n\nI 2022, 42 √•r etter 1980, er vareimporten (litt st√∏rre enn) 10 gongar s√• stor som i 1980.\n\nDersom verdien av vareeksporten i eit land er st√∏rre enn verdien av vareimporten, seier vi at landet har eit handelsoverskot.\n\nSkal no finna ut kva tid det er handelsoverkot.\n\n# definerer funksjonane\ndef imprt(x):\n    return 91 * 1.057**x\n\ndef eksprt(x): \n    return 24.90*x + 36.32\n\n# lagar x-verdiar\nx = np.linspace(0, 50, 1000)\n\n# ser ca. kor dei kryssar kvarandre \nplt.plot(x, imprt(x), \"r\", label=\"import\")\nplt.plot(x, eksprt(x), \"g\", label=\"eksport\")\nplt.grid()\n\n# ca. verdi for det f√∏rste skj√¶ringspunktet, x1\nx_1 = 2\n\n# finn x1\nwhile imprt(x_1) > eksprt(x_1):\n    x_1 += 0.1\n\n# plottar linja og skriv ut\nplt.axvline(x_1)\nprint(f\"Skj√¶ringspunkt 1: {x_1:.1f}\")\n\n# ca. verdi for det andre skj√¶ringspunktet, x2\nx_2 = 45\n\n# finn x2\nwhile imprt(x_2) < eksprt(x_2):\n    x_2 += 0.1\n\n# plottar linja og skriv ut\nplt.axvline(x_2)\nprint(f\"Skj√¶ringspunkt 2: {x_2:.1f}\")\n\nplt.legend()\nplt.show()\n\nSkj√¶ringspunkt 1: 2.9\nSkj√¶ringspunkt 2: 46.5\n\n\n\n\n\n\n\n\n\nDvs. det er handelsoverskot ca. fr√• starten av 1983 til midt i 2026 ut fr√• modellane.\n\n\n\n\nTenk deg at du har ein terning med n sider der talet p√• auge p√• sidene er \\(1, 2, ... , n\\). N√•r du kastar terningen, er alle utfalla like sannsynlege. Du kastar terningen to gonger. La \\(X\\) vere produktet av talet p√• auge i dei to kasta. Dersom til d√∏mes f√∏rste kast gir 7 og andre kast gir 3, blir \\(X\\) lik \\(3\\cdot 7 = 21\\).\n\nStartar med √• la \\(n=10\\) og pr√∏ver √• finna \\(P(X > 60)\\)\n\nimport numpy as np\nrng = np.random.default_rng()\n\nN = 1000000\nn = 10\n\n# triller ternignar\nt1 = rng.integers(1, n+1, size=N)\nt2 = rng.integers(1, n+1, size=N)\n\n# finn produktet av dei to kasta\nprod = t1 * t2\n\n# finn gunstige utfall og sannsynet\ngunstige = sum(prod > 60)\nsannsyn = gunstige / N\n\nprint(f\"N√•r n = 10: \\nP(X > 60) = {sannsyn:.4f}\")\n\nN√•r n = 10: \nP(X > 60) = 0.1302\n\n\nS√• vil me finna ut kva den minste verdien av \\(n\\) som gjer at \\(P(X>60) > 0.5\\) er. Bruker koden vidare, men gjer han om til ein funksjon med input n og output sannsyn. D√• kan ein pr√∏va seg fram med ei while-l√∏kke.\n\ndef trilling(n):\n    N = 1000000\n\n    # triller ternignar\n    t1 = rng.integers(1, n+1, size=N)\n    t2 = rng.integers(1, n+1, size=N)\n\n    # finn produktet av dei to kasta\n    prod = t1 * t2\n\n    # finn gunstige utfall og sannsynet\n    gunstige = sum(prod > 60)\n    sannsyn = gunstige / N\n\n    return sannsyn\n\n# Pr√∏ver oss fram\nn = 10\n\nwhile trilling(n) < 0.5:\n    n += 1\n\nprint(f\"n = {n}: \\nP(X > 60) = {trilling(n):.4f}\")\n\nn = 17: \nP(X > 60) = 0.5062\n\n\n17 er alts√• den minste verdien \\(n\\) kan ha for at \\(P(X>60) > 0.5\\).\n\n\n\n\nArnt har f√•tt ein sjukdom og m√• ta ein tablett som inneheld 100 mg av eit verkestoff. Funksjonen \\(f\\) gitt ved \\[f(t)=100\\cdot e^{‚àí0,012t}\\] er ein modell for kor mykje av verkestoffet til tabletten som er igjen i kroppen \\(t\\) timar etter at han tok den.\n\nF√∏rst skal me finna ut kor mykje stoff som er i kroppen 24 timar etter at han har tatt ein tabelett.\nStartar med √• definera funksjonen.\n\nimport numpy as np\n\ndef f(t):\n    return 100 * np.exp(-0.012*t)\n\netter24 = f(24)\n\nprint(f\"Verkestoff etter 24 timar: {etter24:.2f} mg\")\n\nVerkestoff etter 24 timar: 74.98 mg\n\n\nVidare f√•r me opplyst at\n\nArnt tek ein tablett kvar morgon klokka √•tte. La \\(g\\) vere ein funksjon som beskriv mengda verkestoff han har i kroppen \\(t\\) timar etter at han tok den f√∏rste tabletten.\n\nDet skal argumenterast for om \\(g\\) er ein kontinuerlig funksjon eller ikkje.\nAt den nye tabeletten skal bli tatt opp umiddelbart (at niv√• verkestoff i kroppen gjer eit hopp med 100 mg) er litt vanskeleg √• sj√• for seg om ein tenker at ‚Äúi kroppen‚Äù = ‚Äúi blodet‚Äù. Om ein tenker at ‚Äúi kroppen‚Äù er innafor munnen, s√• kan ein argumentera for at funksjonen er diskontinuerleg med eit slikt hopp‚Ä¶\nS√• skal me finna ut kor mykje verkestoff Arnt har i kroppen like f√∏r den 6. tabletten. Bruker funksjonen fr√• tidlegare. Hugs at \\(t\\) er timar her og ikkje d√∏gn. Startar p√• 1 sidan den ‚Äúnyaste‚Äù tabeletten (nr. 5) har vore eitt d√∏gn i kroppen.\n\nverkestoff = 0\n\nfor i in range(1, 6):\n    verkestoff += f(i*24)\n\nprint(f\"Rett f√∏r tab.nr. 6 er det {verkestoff:.2f} mg i kroppen\")\n\nRett f√∏r tab.nr. 6 er det 228.63 mg i kroppen\n\n\nTil slutt skal me finna ut kor mykje verkestoff Arnt vil ha i kroppen om han tek ein tablett i d√∏gnet over eit lengre tidsrom. Bruker funksjonen og l√∏kka fr√• tidlegare. Startar p√• 0 no sidan me ikkje lenger ser p√• ‚Äúrett f√∏r‚Äù ein tablett. Pr√∏ver meg fram for √• finna ut kor langt fram me m√• sj√• for √• finna taket.\n\nverkestoff = 0\n\nfor i in range(0, 25):\n    verkestoff += f(i*24)\n    print(f\"Dag {i+1:2n}: {verkestoff:.2f} mg\")\n\nDag  1: 100.00 mg\nDag  2: 174.98 mg\nDag  3: 231.19 mg\nDag  4: 273.34 mg\nDag  5: 304.94 mg\nDag  6: 328.63 mg\nDag  7: 346.39 mg\nDag  8: 359.71 mg\nDag  9: 369.70 mg\nDag 10: 377.19 mg\nDag 11: 382.80 mg\nDag 12: 387.01 mg\nDag 13: 390.16 mg\nDag 14: 392.53 mg\nDag 15: 394.30 mg\nDag 16: 395.63 mg\nDag 17: 396.63 mg\nDag 18: 397.38 mg\nDag 19: 397.94 mg\nDag 20: 398.36 mg\nDag 21: 398.67 mg\nDag 22: 398.91 mg\nDag 23: 399.09 mg\nDag 24: 399.22 mg\nDag 25: 399.32 mg\n\n\nDet ser ut som Arnt ikkje vil overstiga 400 mg verkestoff i kroppen p√• lang sikt.\n\n\n\nEin funksjon \\(f\\) er gitt ved \\[f(x)=2x+5+\\frac{1}{x-1}\\]\nL√∏yser oppg√•va i CAS.\na) For kva verdiar av \\(k\\) har likninga \\(f'(x)=k\\) l√∏ysing?\n\n\n\nüì∑ Skjermbilete av CAS\n\n\nL√∏yser liknigna. Ser at \\(k=2\\) gir \\(0\\) i nemnar.\nLikninga har l√∏ysing for \\(k<2\\)\nb) Vel ulike verdiar av \\(k\\), og beskriv symmetrien i l√∏ysingane av likninga \\(f'(x)=k\\) for kvar av desse verdiane\nPr√∏ver tre ulike verdiar for \\(k\\) og ser at alle er symmetriske om linja \\(x=1\\).\n\n\n\nüì∑ Skjermbilete av CAS\n\n\nLa \\(g\\) vere ein funksjon som kan skrivast p√• forma \\[g(x)=a\\cdot x + b + \\frac{1}{x+d}\\]\nc) For kva verdiar av \\(a\\) har likninga \\(g'(x)=4\\) l√∏ysing?\nL√∏yser likninga og ser at likninga har l√∏ysing n√•r \\(a>4\\).\n\n\n\nüì∑ Skjermbilete av CAS\n\n\nLa no \\(a=3\\).\nd) Utforsk og beskriv l√∏ysingane til likninga \\(g'(x)=k\\) for ulike verdiar av \\(k\\).\nSer at no er l√∏ysingane symmetriske om \\(x=-d\\).\n\n\n\nüì∑ Skjermbilete av CAS\n\n\ne) Bestem \\(b\\) og \\(d\\) slik at \\(g'(-1)=g'(5)\\) og \\(g(1)=7\\).\nDersom \\(g'(-1)=g'(5)\\) m√• l√∏ysingane til likninga \\(g'(x)=k\\) vera symmetrisk om \\(x=\\frac{-1+5}{2}=2\\).  Dvs. \\(-d=2 \\Rightarrow d = -2\\).\nD√• er \\[g(x) = 3x + b + \\frac{1}{x-2}\\] og vidare finn me \\(b\\) ved √• l√∏ysa likninga \\(g(1)=7\\)\n\n\n\nüì∑ Skjermbilete av CAS\n\n\nOg me st√•r att med \\[g(x) = 3x + 5 + \\frac{1}{x-2}\\]"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html",
    "href": "posts/lf/S1-V22/index.html",
    "title": "Eksamen V22 S1",
    "section": "",
    "text": "Her er eit forslag til l√∏ysing av v√•reksamen i S1 2022. I del 2 er oppg√•vene stort sett l√∏yst i Python eller CAS.\nEg kan ikkje lova at l√∏ysinga er feilfri‚Ä¶ üòä Gje meg gjerne ein lyd om du ser feil.\n\nMiniatyrbilete: Exam icons created by Freepik - Flaticon\nEksamenssettet finn du hos UDIR: Finn eksamensoppgaver"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 1",
    "text": "Oppg√•ve 1\nSkriv s√• enkelt som r√•d\n\\[ \\begin{align*}\n\\left(2a\\right)^{-1}\\cdot \\left(\\frac{b}{2}\\right)^{-3}\\cdot \\left(a\\cdot b\\right)^3 &= \\frac{1}{2a}\\cdot \\frac{2^3}{b^3}\\cdot a^3 \\cdot b^3 \\\\\n&= \\frac{2^3 \\cdot a^3 \\cdot b^3}{2\\cdot a \\cdot b^3} \\\\\n&= 2^2 \\cdot a \\\\ &= 4a\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-2",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-2",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 2",
    "text": "Oppg√•ve 2\nDagleg produksjonskostnad for \\(x\\) luer gitt ved \\[E(x)=0,2x+40+\\frac{20000}{x}\\]\nDeriverer \\(E(x)\\)\n\\[E'(x) = 0,2 + 0 + 20000\\cdot \\frac{-1}{x^2} = 0,2 - \\frac{20000}{x^2}\\]\nDermed f√•r me\n\\[E'(100)=0,2-\\frac{20000}{10000} = 0,2-2 = -1,8\\]\nDette betyr at ved 100 produserte einingar vil endringa i produksjonskostnaden vera \\(-1,8\\). Alts√• vil det bli om lag 1,8 kr billegare √• produsere kvar lue om ein aukar produksjonen fr√• 100 til 101."
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-3",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-3",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 3",
    "text": "Oppg√•ve 3\n\\[\n\\begin{align*}\n    \\lim_{x\\rightarrow 3} \\frac{x-3}{x^2+x-12} &= \\lim_{x\\rightarrow 3} \\frac{x-3}{(x+4)(x-3)} \\\\\n    &= \\lim_{x\\rightarrow 3} \\frac{1}{x+4} \\\\\n    &= \\frac{1}{3+4} \\\\\n    &= \\frac{1}{7}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-4",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-4",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 4",
    "text": "Oppg√•ve 4\nSkal l√∏ysa likninga \\(e^{2x}-e^x=2\\). Bruker at \\(e^{2x}=\\left(e^x\\right)^2\\). Dermed f√•r me \\[\\left(e^x\\right)^2 - e^x = 2\\]\nBytter ut \\(e^x\\) med \\(u\\) og l√∏yser andregradslikninga for \\(u\\)\n\\[\n\\begin{align*}\n    u^2 - u &= 2 \\\\\n    u^2 - u - 2 &= 0 \\\\\n    (u+1)(u-2)&= 0 \\\\\n    u=-1 &\\vee u = 2 \\\\\n    \\text{Som vil seie at} \\\\\n    e^x = -1 &\\vee e^x =2 \\\\\n\\end{align*}\n\\]\nTar logarimten av begge sider for √• f√• \\(x\\) for √• finna \\(x\\). F√•r kun ei l√∏ysing, \\(x = \\ln(2)\\), sidan den naturlege logaritmen kun er definert for positive tal."
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-5",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-5",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 5",
    "text": "Oppg√•ve 5\nSet inn \\(x=7\\) i likninga \\[ \\begin{align*}\n    \\lg(x+3) + \\lg (x) &= \\lg(a) \\\\\n    \\lg(10) + \\lg(7) &= \\lg(a) \\\\\n    \\lg(10\\cdot 7) &= \\lg(a)\n\\end{align*} \\]\nDermed er \\(a=70\\)."
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-6",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-6",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 6",
    "text": "Oppg√•ve 6\n\na) programkode\nN√•r programmet k√∏yrer vil det bli trilla to terningar 1000000 gongar (N). Ein tel opp kor mange av desse kasta summen av terningane blir 9 (gunstige). Til slutt skriv ein ut den relative frekvensen (gunstige/N).\nEleven √∏nsker √• finna ut kva sannsynet for at eit terningkast med to terningar gir summen 9 (eller ein terning kasta to gongar).\n\n\nb) sannsynsrekning\nTel opp antall gunstige utfall (her er det lurt √• teikne t.d. tabell eller valtre).\nDet er \\(4\\) utfall som gjev \\(9\\) som sum. (\\(3+6\\), \\(4+5\\), \\(5+4\\) og \\(6+3\\)).\nVidare er det \\(6\\cdot 6 = 36\\) moglege utfall.\n\\[P(\\text{summen er 9}) = \\frac{\\text{gunstige}}{\\text{moglege}} = \\frac{4}{36}=\\frac{1}{9}\\]"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-1-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-1-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 1",
    "text": "Oppg√•ve 1\nTabellen nedanfor viser talet p√• gardsbruk i Noreg for nokre gitte √•rstal.\n\n\n\n√Ör\nTal gardsbruk\n\n\n\n\n1969\n154 977\n\n\n1989\n99 382\n\n\n1999\n68 539\n\n\n2009\n47 688\n\n\n2020\n38 633\n\n\n\n\na) modell for framtida\nPlottar f√∏rst datapunkta for √• f√• ei oversikt over korleis det ser ut\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n√•r = [0, 20, 30, 40, 51]\ng√•rdar = [154977, 99382, 68539, 47688, 38633]\n\nplt.plot(√•r, g√•rdar, \"ro\")\nplt.show()\n\n\n\n\nDet kan sj√• ut som om nedgangen vert mindre og mindre. Ser om det kan passa med ein modell for prosentvis nedgang (eksponentiell modell).\nBruker curve_fit for √• finna ein funksjon p√• forma \\(f(x)=a \\cdot b^x\\)\n\nfrom scipy.optimize import curve_fit\n\ndef f(x, a, b):\n    return a*b**x\n\nK, E = curve_fit(f, √•r, g√•rdar)\n\na, b = K\n\nx_verdiar = np.linspace(0, 65, 1000)\n\nplt.plot(x_verdiar, f(x_verdiar, a, b))\nplt.plot(√•r, g√•rdar, \"ro\")\nplt.ylim([0, 160000])\nplt.show()\nprint(f\"f(x)={a:.1f}*{b:.3f}^x\")\n\n\n\n\nf(x)=157256.2*0.973^x\n\n\nDet kan sj√• ut som modellen \\[f(x)=157256 \\cdot 0,973^x\\] passar fint med datapunkta.\nI tillegg er det naturleg √• tenka at talet p√• gardsbruk vil ha ein prosentvis nedgang som den i modellen over. P√• 60-70-talet var det mange sm√• g√•rdsbruk som har blitt slukt av st√∏rre g√•rdar. Med tanke p√• at me framleis held p√• med matproduksjon og landbruk, vil denne nedgangen i sm√• gardsbruk (og auken i store) bli mindre og mindre over tid.\n\n\nb) framtida\nReknar ut \\(f(2060-1969)\\):\n\nx = 2060-1969\nframtid = f(x, a, b)\nprint(f\"G√•rdar i 2060: \\nf({x}) = {framtid:.0f}\")\n\nG√•rdar i 2060: \nf(91) = 13248\n\n\nDet er vanskeleg √• seie mykje om dette svaret utan meir bakgrunnskunnskap og andre data. Likevel tenker eg at det er eit rimeleg svar, dersom t.d. automatisering og liknande effektiviserer landbruket, slik at det trengs f√¶rre b√∏nder (og gjerne f√¶rre g√•rdar). P√• den andre sida kan det tenkast at ustabile globale tilh√∏ve p√• matforsyning gjer at talet p√• g√•rdsbruk vert h√∏gare. Som sagt, vanskeleg √• seie noko om.\n\n\nc) nedgang med 1000\nHer kunne me jo l√∏yst likninga \\(f'(x)=-1000\\), men me pr√∏ver oss p√• ein annan framgongsm√•te i Python.\nLagar ei while-l√∏kke som ser p√• skilnaden mellom eit √•r og det neste. Av grafen veit/ser me at i starten er nedgangen mykje st√∏rre enn 1000 i √•ret (ca. 56 000 f√¶rre fr√• 1969 til 1989). Held difor p√• s√• lenge skilnaden p√• to p√•f√∏lgjande √•r er st√∏rre enn 1000 (bruker absoluttverdi)\n\nx = 0\n\nf0 = f(x, a, b)\nf1 = f(x+1, a, b)\n\nwhile abs(f1-f0) >= 1000:\n    x +=1 \n    f0 = f(x, a, b)\n    f1 = f(x+1, a, b)\n\nprint(f\"x = {x}\")\nprint(f\"f({x}) = {f0:.1f}\")\nprint(f\"f({x+1}) = {f1:.1f}\")\nprint(f\"Endring: {(f1-f0):.1f}\")\n\nx = 53\nf(53) = 37224.1\nf(54) = 36225.7\nEndring: -998.4\n\n\nSer at n√•r \\(x=53\\) er nedgangen ca. 1000 g√•rdsbruk. Dvs. kring √•r 2022.\n\n\n\n\n\n\nL√∏yse symbolsk i sympy\n\n\n\nMe kan l√∏ysa likninga \\(f'(x)=-1000\\) med sympy/CAS\n\n\nVis koden\n# importerer aktuelle funksjonar fr√• sympy\nfrom sympy import Symbol, diff, Eq, Reals, solveset\n\n# definerer x\nx = Symbol(\"x\")\n\n# definerer funksjonen og deriverer\nf = a * b**x\ndf = diff(f, x)\n\n# set opp likninga, og l√∏yser den\nlikning = Eq(df, -1000)\nl√∏ysing = solveset(likning, x, domain=Reals)\n\n# skriv ut svaret\nprint(f\"x = {l√∏ysing.evalf(3)}\")\n\n\nx = {53.4}"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-2-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-2-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 2",
    "text": "Oppg√•ve 2\n\na) binomisk fors√∏k?\nDersomm dette skal vera eit binomisk fors√∏k m√• me g√• ut fr√• at sannsynet for at kvar av dei best√•r er det same (74 %) og at oppk√∏yringa til kvar av elevane er uavhengige ‚Äúdelfors√∏k‚Äù. Dvs. at om ein elev stryk (eller best√•r) oppk√∏yringa s√• p√•verkar ikkje det resultatet til dei andre. I tillegg er det her slik at kvar delfors√∏k kun har to utfall, best√• og ikkje best√•.\nI praksis vil nok ikkje sannynet vera det samme for kvar elev. Ein har ulike f√∏resetnader, er ulikt f√∏rebudd, vert ulikt p√•verka av nerver/stress osb. I tillegg kan ein tenka seg at om ein av dei stryk (og dei andre f√•r h√∏yra det) s√• kan det p√•verka oppk√∏yringa til nestemann.\n\n\nb) sannsyn for at 8 av 12 best√•r\nFor √• finna dette sannsynet kan me simulera dei 12 oppk√∏yringane mange gongar og telja opp kor mange av dei minst 8 best√•r. Me antar at dette kan sj√•ast p√• som eit binomisk fors√∏k.\n\nimport numpy as np\nrng = np.random.default_rng()\n\nN = 1000000 # tal simuleringar\nn = 12      # tal elevar\np = 0.74    # sannynet for suksess (best√•)\nX = 8       # minst X suksess\n\n# simulerer\noppk√∏yringar = rng.binomial(n, p, size = N)\n\n# tel opp\ngunstige = sum(oppk√∏yringar >= X)\n\n# finn og skriv ut sannsynet\nsannsyn = gunstige/N\nprint(f\"P(X >= 8) = {sannsyn:.4f}\")\n\nP(X >= 8) = 0.8211\n\n\n\n\nc) akkurat 5 gutar og 4 jenter\nSer p√• gutane og jentene for seg. Multipliserer saman sannsyna sidan dei to hendingane er uavhengige.\n\nN = 1000000 # tal simuleringar\nn_g = 7     # tal gutar\nX_g = 5     # gutar som best√•r\nn_j = 5     # tal jenter\nX_j = 4     # jenter som best√•r\np = 0.74    # sannynet for suksess (best√•)\n\n# simulerer\ngutar = rng.binomial(n_g, p, size=N)\njenter = rng.binomial(n_j, p, size=N)\n\n# tel opp\ngunstige_g = sum(gutar == X_g)\ngunstige_j = sum(jenter == X_j)\n\n# finn og skriv ut sannsynet\nsannsyn_g = gunstige_g/N\nsannsyn_j = gunstige_j/N\n\n# hendingane er uavhengige, dermed f√•r me:\nsannsyn = sannsyn_g * sannsyn_j\nprint(f\"P(5 gutar og 4 jenter) = {sannsyn:.4f}\")\n\nP(5 gutar og 4 jenter) = 0.1232"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-3-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-3-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 3",
    "text": "Oppg√•ve 3\n70 000 kr p√• konto, med fast m√•nadleg rentesats \\[B(x) = 70000\\cdot 1,003^x\\]\n\na) √•rleg rentesats\n\nprint(1.003**12)\n\n1.03659998028813\n\n\nKnut har ein √•rleg rentesats p√• ca. 3,7 prosent.\n\n\nb) 80 000 kroner\nL√∏yser likninga \\(B(x)=80000\\).\n\nfrom sympy import Symbol, Eq, solveset, Reals\n\nx = Symbol(\"x\")\n\nlikning = Eq(70000*1.003**x, 80000)\nl√∏ysing = solveset(likning, x, domain=Reals)\nprint(l√∏ysing.evalf(3))\n\n{44.6}\n\n\n\nprint(45 // 12)\nprint(45 % 12)\n\n3\n9\n\n\nDet tek 45 m√•nader, 3 √•r og 9 m√•nader, f√∏r bel√∏pet har passert 80000 kr.\n\n\nc) kontinuerleg?\nAksjefond: 2000 kroner inn kvar m√•nad (0,7 prosent avkasting per mnd.)  Konto: 0.3% renter.\n\\(T(x)\\) er den totale verdien av aksjefond og sparekonto.\nSidan han set inn 2000 kroner kvar m√•nad vil funksjonen gjera eit hopp p√• desse tidspunkta, og ikkje vera kontinuerleg.\n\n\nd) meir enn 200 000 kroner?\nPr√∏ver oss fram i Python.\n\n# etter n√∏yaktig 24 m√•nader\nkonto = 70000*1.003**24\nfond = 2000\ntotal = konto + fond\nmnd = 0\n\nwhile total < 200000:\n    konto *= 1.003\n    fond = fond*1.007 + 2000\n    total = konto + fond\n    mnd += 1\n    \nprint(f\"Etter {mnd} m√•nader er det {total:.2f} kr\")\n\nEtter 47 m√•nader er det 200218.45 kr"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-4-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-4-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 4",
    "text": "Oppg√•ve 4\nSimulerer i Python.\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# antall kast\nN = 1000000\n\n# dei tre terningane N kast\nt1 = rng.integers(1, 7, N)\nt2 = rng.integers(1, 7, N)\nt3 = rng.integers(1, 7, N)\n\n# produktet av terningane, per kast\nprod = t1 * t2 * t3\n\n# tel opp gunstige utfall\ngunstige = sum(prod > 100)\n\n# finn sannsynet\nsannsyn = gunstige / N\nprint(f\"Sannsynet for √• vinna er {sannsyn:.4f}\")\n\nSannsynet for √• vinna er 0.0924\n\n\nK√∏yrer programmet eit par gongar og ser at resultatet vert ganske likt. Sannsynet for √• vinna er ca. 0,092"
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-5-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-5-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 5",
    "text": "Oppg√•ve 5\nBreidda p√• rektangelet er \\(2\\cdot a\\) medan h√∏gda er \\(b\\), som er \\(y\\)-verdien til skj√¶ringspunktet mellom linja fr√• \\((0, 2)\\) til \\((2, 0)\\) og \\(x=a\\).\nLinja har stigningstal \\(-1\\) og konstantledd \\(2\\). Dvs. \\(f(x)=2-x\\).\nDermed er h√∏gda til rektangelet \\(2-a\\). Arealet vert d√• \\[T = 2 \\cdot a \\cdot b = 2\\cdot a \\cdot(2-a) = 4a - 2a^2\\]\nDefinerer \\(T(a)\\) som funksjon, deriverer og finn den \\(a\\)-verdien som gjev st√∏rst \\(T\\). (st√∏rst sidan \\(T\\) er ein konkav/‚Äúsur‚Äù parabel).\n\nfrom sympy import Symbol, diff, Eq, solveset, Reals\na = Symbol(\"a\")\n\nT = 4*a - 2*a**2\ndT = diff(T, a)\n\nlikning = Eq(dT, 0)\nl√∏ysing = solveset(likning, a, domain=Reals)\nprint(l√∏ysing)\n\n{1}\n\n\nDet vil seie at \\(a=1\\) gir st√∏rst areal. D√• er \\[T(1)=4\\cdot 1 - 2\\cdot 1^2 = 2\\]\n\\(2\\) er den st√∏rste verdien \\(T\\) kan ha."
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-6-1",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-6-1",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 6",
    "text": "Oppg√•ve 6\nTemperaturen \\(T\\) etter \\(t\\) min er\n\\[\\ln(T-T_0)=-k\\cdot t + r\\]\nder \\(T_0\\) er romtepmeratur og \\(k\\) og \\(r\\) konstantar.\nF√•r oppgitt at - \\(T_0=22\\) - \\(T=82\\) n√•r \\(t=0\\) - \\(T=66\\) n√•r \\(t=2\\)\nDermed har me likningane\n\\[\\begin{align*}\n    \\ln(82-22) &= -k\\cdot 0 + r &&=r \\\\\n    \\ln(66-22) &= -k\\cdot 2 + r &&= r-2k\n\\end{align*} \\]\n\nfrom sympy import Symbol, Eq, nsolve, solveset, Reals, log\n\n# definerer r og k\nr = Symbol(\"r\")\nk = Symbol(\"k\")\n\n# definerer likningane\nl1 = Eq(log(82-22), r)\nl2 = Eq(log(66-22), r-2*k)\n\n# finn numerisk verdi for r og k\nl√∏ysing = nsolve([l1, l2], [r, k], [1,1])\n\n# definerer t og ny likning med verdiar for r og k\nt = Symbol(\"t\")\nr_n = l√∏ysing[0]\nk_n = l√∏ysing[1]\nl_temp = Eq(log(40-22), -k_n * t + r_n)\n\n# l√∏yser for t og skriv ut. \nny_t = solveset(l_temp, t)\nprint(f\"t = {ny_t.evalf(3)}\")\n\nt = {7.76}\n\n\nDet tar rett over 7 min og 45 sek f√∏r temperaturen n√•r 40 grader."
  },
  {
    "objectID": "posts/lf/S1-V22/index.html#oppg√•ve-7",
    "href": "posts/lf/S1-V22/index.html#oppg√•ve-7",
    "title": "Eksamen V22 S1",
    "section": "Oppg√•ve 7",
    "text": "Oppg√•ve 7\nSer p√• dei ulike grafane og ser at\n\nA har\n\nekstremalpunkt i \\(x\\approx -1\\) og \\(x\\approx 1\\)\n\nvoksande f√∏r det f√∏rste ekstremalpunktet (toppunkt)\nsynkande mellom ekstremalpunkta\nvoksande etter det siste ekstremalpunktet (botnpunkt)\n\nnullpunkt (og vendepunkt) i origo\n\ngrafen s√∏kk og brattast her\n\n\nD har\n\nnullpunkt i \\(x\\approx -1\\) og \\(x\\approx 1\\)\nekstremalpunkt i origo (botnpunkt)\n\n\nDermed er A grafen til \\(f\\) og D er grafen til \\(f'\\).\nSer vidare at\n\nB har\n\nnullpunkt i \\(x\\approx 1,5\\)\npositiv f√∏r nullpunktet\nnegativ etter nullpunktet\n\nC har\n\nekstremalpunkt (toppunkt) i \\(x\\approx 1,5\\)\n\n\nDermed er C grafen til \\(g\\) og B er grafen til \\(g'\\)."
  },
  {
    "objectID": "posts/230303_simulering2/index.html",
    "href": "posts/230303_simulering2/index.html",
    "title": "Samansett simulering i S2",
    "section": "",
    "text": "Ein del problemstillingar kan vera ganske vanskelege √• l√∏ysa ved rekning. Simulering kan hjelpa til √• gjera denne type oppg√•ver mykje lettare √• l√∏ysa. I dag ser me p√• ei oppg√•ve henta fr√• eksempelsettet til skriftleg eksamen etter ny l√¶replan i S2.\nTa gjerne ein kikk p√• dette innlegget om du treng oppfrisking i grunnleggande simulering med NumPy. Ellers er dokumentasjonen til NumPy ein fin stad √• vera‚Ä¶\n\n\n\nP√• ein skule er det 323 jenter og 301 gutar. La \\(X\\) vera h√∏gda til ei tilfeldig vald jente og \\(Y\\) vera h√∏gda til ein tilfeldig vald gut. Me g√•r ut fr√• at \\(X\\) og \\(Y\\) er normalfordelt med \\(\\mu_x=168 cm\\), \\(\\mu_y=180 cm\\), \\(\\sigma_x = 6 cm\\) og \\(\\sigma_y = 8 cm\\).   Lag eit program som du kan bruka til √• simulera sannsynet for at ein tilfeldig vald elev er h√∏gare enn 175 cm. Bestem dette sannsynet.   (UDIR - Eksempelsett eksamen S2-V23 oppg√•ve 6, del 2)\n\nüßê Me m√• alts√• b√•de bestemma om det er gut eller jente me har trekt i tillegg til √• finna h√∏gda p√• eleven. Krevande for hand/analytisk men ikkje s√• aller verst √• finna ut av ved simulering!"
  },
  {
    "objectID": "posts/230303_simulering2/index.html#l√∏kker",
    "href": "posts/230303_simulering2/index.html#l√∏kker",
    "title": "Samansett simulering i S2",
    "section": "1Ô∏è‚É£ L√∏kker",
    "text": "1Ô∏è‚É£ L√∏kker\nTanken her er √• trekka ein elev N gongar. Trekk eit tal mellom 0 og 323+301, og seier at dei 323 f√∏rste (fom. 0 tom. 322) er jenter, og dei siste (resten) er gutar. Simulerer h√∏gda til kvar elev etter det. Tel til slutt opp kor mange som er over 175 cm.\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# tal simuleringar\nN = 10000000\n\n# N elevar (tal mellom 0 og 323+301)\nelevar = rng.integers(0, (323+301), size=N)\n\n# tom liste til h√∏gdene\nh√∏gdar = []\n\n# Finn h√∏gda til kvar elev\nfor elev in elevar:\n    if elev<323: # 0 til 322 er jenter\n        h√∏gdar.append(rng.normal(168, 6))\n    else: # 323 til 323+301 er gutar\n        h√∏gdar.append(rng.normal(180, 8))\n\n# tel opp elevar h√∏gare enn 175 cm\ngunstige = sum(np.array(h√∏gdar)>175)\nsannsyn = gunstige / N\n\nprint(f\"Sannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er {sannsyn:.4f}\")\n\nSannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er 0.4172\n\n\n‚è≥ Her brukte maskina mi ca. 17 sek. p√• 10 000 000 simuleringar."
  },
  {
    "objectID": "posts/230303_simulering2/index.html#funksjonar",
    "href": "posts/230303_simulering2/index.html#funksjonar",
    "title": "Samansett simulering i S2",
    "section": "2Ô∏è‚É£ funksjonar‚Ä¶",
    "text": "2Ô∏è‚É£ funksjonar‚Ä¶\nHer gjer me 1Ô∏è‚É£ litt meir fancy. Mykje lik tankegang.\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# tal simuleringar\nN = 10000000\n\n# finn sannsyn jente og sannsyn gutt\np = np.array([323, 301]) / (323+301)\n\n# lagar funksjon som trekk ein elev\ndef trekk_elev(p):\n    h√∏gde = 0\n    # trekk kj√∏nn:\n    kj√∏nn = rng.choice(['j', 'g'], p=p)\n    \n    # trekk h√∏gde (ut fr√• trekt kj√∏nn)\n    if kj√∏nn == 'j':\n        h√∏gde = rng.normal(168, 6, 1)\n    else: \n        h√∏gde = rng.normal(180, 8, 1)\n    \n    return h√∏gde[0]\n\n# tel opp talet elevar som er over 175 cm\ngunstig = 0\n\nfor i in range(N):\n    h = trekk_elev(p)\n    if h>175:\n        gunstig += 1\n\n# finn og skriv ut relativ frekvens\nsannsyn = gunstig/N\nprint(f\"Sannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er {sannsyn:.4f}\")\n\nSannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er 0.4169\n\n\n‚è≥ Her brukte maskina mi ca. 5 min. (!!!) p√• 10 000 000 simuleringar."
  },
  {
    "objectID": "posts/230303_simulering2/index.html#alt-i-arrays",
    "href": "posts/230303_simulering2/index.html#alt-i-arrays",
    "title": "Samansett simulering i S2",
    "section": "3Ô∏è‚É£ Alt i arrays üöÄ",
    "text": "3Ô∏è‚É£ Alt i arrays üöÄ\nFor √• gjera programmet effektivt, raskt og lett leseleg droppar eg l√∏kker og funksjonar.\n\nimport numpy as np\nrng = np.random.default_rng()\n\n# antall jenter, gutar og elevar p√• skulen\nj = 323\ng = 301\nn = j + g\n\n# tal simuleringar\nN = 10000000\n\n# finn antall gutar (0) og jenter (1)\nkj√∏nn = rng.choice([0,1], size=N, p=[g/n, j/n])\njenter = sum(kj√∏nn)\ngutar = N - jenter\n\n# finn h√∏gder p√• jenter og gutar for seg\nh_jenter = rng.normal(168, 6, size=jenter)\nh_gutar = rng.normal(180, 8, size=gutar)\n\n# h√∏gder p√• alle dei trekte elevane\nh_trekte = np.append(h_jenter, h_gutar)\n\n# reknar ut sannsynet\ngunstige = sum(h_trekte > 175)\nsannsyn = gunstige / N\n\nprint(f\"Sannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er {sannsyn:.4f}\")\n\nSannsynet for at ein tilfeldig elev er h√∏gare enn 175 cm er 0.4168\n\n\n‚ö° 3,4 sek. p√• 10 000 000 simuleringar! üòé"
  },
  {
    "objectID": "posts/230425_jordskjelv/index.html",
    "href": "posts/230425_jordskjelv/index.html",
    "title": "Jordskjelvpython",
    "section": "",
    "text": "I dette opplegget tek me utgangspunkt i store mengdar ekte jordskjelvdata. Desse vil me systematisera og visualisera ved hjelp av biblioteket geopandas i Python üêç  D√∏me p√• ein av figurane me kjem til √• laga ser du under.\n\n\n\nüì∑ D√∏me p√• figur\n\n\n\n\n\n\n\n\nMerk\n\n\n\nFor √• gjennomf√∏ra denne √∏vinga treng ein biblioteket geopandas. Viss ein nyttar anaconda eller miniconda s√• er det enklaste √• laga eit eige enviroment for √• ikkje klussa til den ¬´vanlege¬ª python-installasjonen. Oppskrifta du finn her, funkar fint!\n\n\n\n\nF√∏rst treng me eit datasett. USGS har ein eigen ¬´jordskjelvkatalog¬ª der ein kan s√∏ka etter og lasta ned jordskjelvdata. Katalogen finn du her.\nDet meste ein kan lasta ned er 20 000 jordskjelv, s√• me m√• gjera nokre val i innstillingane for √• f√• dekka eit lengre tidsrom.\nBasic options  Magnitude b√∏r ha Minimum sett til 5,5.  Date & Time sin Start b√∏r vera s√• tidleg som mogleg (gjerne 1950 berre for √• ta litt i‚Ä¶)  Geographic Region st√•r p√• World\nOutput options  Format ‚û°Ô∏è csv  Order By ‚û°Ô∏è Time - Newest First  Limit Results b√∏r ha Number of Events sett til 20000 (for √• unng√• feilmelding om for mange treff)\nDen nedlasta fila b√∏r ligga i same mappe som Jupyter-notatboka (eller .py-fila). For √• gjera det enklare for oss sj√∏lv kan me √≤g endra namn p√• fila til skjelv.csv eller liknande.\nüü¢ Eg tilr√•r p√• det sterkaste √• gjera denne type programmering/utforsking i ei Jupyter-notatbok\n\n\n\nMe startar med √• importere naudsynte bibliotek.\n\nimport pandas as pd\nimport geopandas as gpd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nBruker s√• pandas for √• lesa inn csv-fila.\n\nskjelv = pd.read_csv(\"skjelv.csv\")\n\nUnders√∏ker korleis den innleste tabellen ser ut\n\nskjelv.shape\n\n(20000, 22)\n\n\n(20000, 22) betyr alts√• at me her har ein tabell med 20 000 rader og 22 kolonner. Ser p√• dei fem f√∏rste radene i tabellen.\n\nskjelv.head()\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      magType\n      nst\n      gap\n      dmin\n      rms\n      ...\n      updated\n      place\n      type\n      horizontalError\n      depthError\n      magError\n      magNst\n      status\n      locationSource\n      magSource\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n      mww\n      70.0\n      58.0\n      2.282\n      0.91\n      ...\n      2023-04-25T07:46:47.683Z\n      170 km SSE of Teluk Dalam, Indonesia\n      earthquake\n      7.35\n      3.944\n      0.060\n      27.0\n      reviewed\n      us\n      us\n    \n    \n      1\n      2023-04-24T02:17:56.596Z\n      -60.3893\n      -26.1923\n      10.000\n      5.6\n      mb\n      80.0\n      68.0\n      19.029\n      0.60\n      ...\n      2023-04-25T02:21:51.035Z\n      South Sandwich Islands region\n      earthquake\n      11.61\n      1.868\n      0.054\n      120.0\n      reviewed\n      us\n      us\n    \n    \n      2\n      2023-04-24T00:41:55.460Z\n      -29.9676\n      -177.8264\n      43.063\n      7.1\n      mww\n      126.0\n      23.0\n      0.708\n      0.50\n      ...\n      2023-04-25T00:46:45.081Z\n      NaN\n      earthquake\n      8.37\n      4.305\n      0.048\n      42.0\n      reviewed\n      us\n      us\n    \n    \n      3\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n      mww\n      124.0\n      53.0\n      2.424\n      0.74\n      ...\n      2023-04-23T21:21:04.014Z\n      170 km NW of Tuapejat, Indonesia\n      earthquake\n      7.18\n      1.806\n      0.060\n      27.0\n      reviewed\n      us\n      us\n    \n    \n      4\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n      mww\n      178.0\n      34.0\n      2.286\n      0.80\n      ...\n      2023-04-23T17:12:44.119Z\n      Kepulauan Batu, Indonesia\n      earthquake\n      7.17\n      3.202\n      0.054\n      33.0\n      reviewed\n      us\n      us\n    \n  \n\n5 rows √ó 22 columns\n\n\n\nMe kan sj√• litt n√¶rare p√• dei statistikk fr√• dei numeriske kolonnene med √• bruka describe()\n\nskjelv.describe()\n\n\n\n\n\n  \n    \n      \n      latitude\n      longitude\n      depth\n      mag\n      nst\n      gap\n      dmin\n      rms\n      horizontalError\n      depthError\n      magError\n      magNst\n    \n  \n  \n    \n      count\n      20000.000000\n      20000.000000\n      20000.000000\n      20000.000000\n      7472.000000\n      10086.000000\n      4430.000000\n      19759.000000\n      3972.000000\n      7242.000000\n      3136.000000\n      4912.000000\n    \n    \n      mean\n      -0.308104\n      33.349754\n      70.485546\n      5.873034\n      267.023555\n      43.510441\n      4.347339\n      0.998922\n      7.115259\n      3.991525\n      0.059346\n      49.099959\n    \n    \n      std\n      30.063869\n      126.560024\n      127.629767\n      0.420587\n      160.409087\n      28.936826\n      5.492807\n      0.203466\n      2.309055\n      7.902934\n      0.031396\n      62.611998\n    \n    \n      min\n      -77.080000\n      -179.997000\n      -3.000000\n      5.500000\n      0.000000\n      8.000000\n      0.008000\n      0.040000\n      0.085000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      25%\n      -20.436500\n      -82.415450\n      10.000000\n      5.600000\n      138.000000\n      24.000000\n      1.167250\n      0.880000\n      5.800000\n      1.800000\n      0.046000\n      19.000000\n    \n    \n      50%\n      -4.496500\n      96.297000\n      31.700000\n      5.700000\n      242.000000\n      36.000000\n      2.535000\n      1.000000\n      7.100000\n      2.000000\n      0.055000\n      33.000000\n    \n    \n      75%\n      22.324750\n      143.512750\n      50.300000\n      6.000000\n      372.000000\n      54.000000\n      5.144000\n      1.110000\n      8.500000\n      4.400000\n      0.068000\n      56.250000\n    \n    \n      max\n      86.922900\n      179.998100\n      700.000000\n      9.100000\n      934.000000\n      313.000000\n      39.730000\n      2.820000\n      15.800000\n      569.200000\n      0.700000\n      941.000000\n    \n  \n\n\n\n\nI kolonna mag (styrken) ser me at b√•de gjennomsnittet (5,87) og medianen (5,7) er ganske l√•ge. Hugs p√• at den l√•gaste verdien her er 5,5. Tala viser oss at 50% av dei 20000 skjelva er mellom 5,5 og 5,7 i styrke. Me ser √≤g at gjennomsnittsdjupna p√• skjelva er ca. 70,5 km (depth).\nSom me har sett over har tabellen mange kolonner, ikkje alle er like relevante for oss. Me kan sortera ut dei me treng vidare. Skriv f√∏rst ut ei liste med kolonnenamn for √• f√• oversikt over alle kolonnene.\n\nskjelv.columns\n\nIndex(['time', 'latitude', 'longitude', 'depth', 'mag', 'magType', 'nst',\n       'gap', 'dmin', 'rms', 'net', 'id', 'updated', 'place', 'type',\n       'horizontalError', 'depthError', 'magError', 'magNst', 'status',\n       'locationSource', 'magSource'],\n      dtype='object')\n\n\n\n\n\nDet f√∏rste me gjer er √• luka ut dei radene som ikkje er jordskjelv. I koden under tek me kun vare p√• dei radene der type er earthquake.\n\nskjelv = skjelv[skjelv[\"type\"] == \"earthquake\"]\nskjelv.shape\n\n(19890, 22)\n\n\nMe ser at tabellen vart nokre rader kortare.\nPlukker ut dei mest relevante kolonnene. Dato, lengde- og breddegrad, djupne og styrke:\n\nskjelv = skjelv[[\"time\", \"latitude\", \"longitude\", \"depth\", \"mag\"]]\nskjelv.head()\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n    \n    \n      1\n      2023-04-24T02:17:56.596Z\n      -60.3893\n      -26.1923\n      10.000\n      5.6\n    \n    \n      2\n      2023-04-24T00:41:55.460Z\n      -29.9676\n      -177.8264\n      43.063\n      7.1\n    \n    \n      3\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n    \n    \n      4\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n    \n  \n\n\n\n\nSjekkar for ordens skuld kva tid det f√∏rste skjelvet er fr√•. Ser p√• dei siste 5 radene i tabellen.\n\nskjelv.tail(5)\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      geometry\n    \n  \n  \n    \n      19994\n      1982-08-06T20:46:13.910Z\n      -8.319\n      120.416\n      49.9\n      5.5\n      POINT (120.41600 -8.31900)\n    \n    \n      19995\n      1982-08-06T20:40:52.200Z\n      -8.375\n      120.577\n      45.7\n      5.9\n      POINT (120.57700 -8.37500)\n    \n    \n      19996\n      1982-08-05T20:42:07.300Z\n      -12.347\n      166.247\n      20.0\n      5.5\n      POINT (166.24700 -12.34700)\n    \n    \n      19997\n      1982-08-05T20:32:52.950Z\n      -12.597\n      165.931\n      30.7\n      7.0\n      POINT (165.93100 -12.59700)\n    \n    \n      19999\n      1982-08-05T07:28:08.810Z\n      -5.767\n      146.567\n      113.0\n      5.6\n      POINT (146.56700 -5.76700)\n    \n  \n\n\n\n\n\n\nFor √• sj√• (og presentera) fordelinga av styrke og djupne kan me t.d. laga heilt enkle boksplot. Startar med eit for styrken üí™\n\nboksplot = skjelv.boxplot(column = \"mag\", figsize = (6,6), color = \"red\")\nplt.title(\"Boksplott over styrkene p√• skjelva\", fontsize = 20)\nplt.ylabel(\"Magnitude\", fontsize = 16)\nplt.show()\n\n\n\n\nFiguren her viser at jordskjelva i all hovudsak er mellom 5,5 og ca. 6,6. Dei sterkare skjelva er s√• f√• at dei vert sett p√• som avvik (outliers).\n\nboksplot = skjelv.boxplot(column = \"depth\", figsize = (6,6), color = \"red\")\nplt.title(\"Boksplott over djupne p√• skjelva\", fontsize = 20)\nplt.ylabel(\"Djupne (km)\", fontsize = 16)\nplt.show()\n\n\n\n\nFiguren for djune viser oss at dei aller fleste skjelva er mellom 0 og 110 km djupe.\n\n\n\n\n\n\nTips til meir visualisering üëÄ\n\n\n\nDet g√•r an √• pr√∏va seg fram med ulike visualiseringar, feks. histogram/stolpediagram. Eventuelt kan ein sjekka ut seaborn dokumentasjon her og laga enno fleire fancy figurar, feks. fiolinplot eller andre fine oversikter.\n\n\n\n\n\n\nF√∏rst lagar me ei geodataframe fr√• v√•r opprinnelege dataframe (skjelv). Forskjellen p√• desse to er at f√∏rstnevnte har ei eigen kolonne geometry, som er punkt, linjer eller flater. I dette tilfelet punkt, som geopandas finn i lengde- og breiddegrad-kolonnene.\n\nskjelv_gdf = gpd.GeoDataFrame(\n    skjelv, \n    geometry = gpd.points_from_xy(\n        skjelv.longitude, \n        skjelv.latitude\n        )\n    )\nskjelv_gdf.head()\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      geometry\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n      POINT (98.53390 -0.78100)\n    \n    \n      1\n      2023-04-24T02:17:56.596Z\n      -60.3893\n      -26.1923\n      10.000\n      5.6\n      POINT (-26.19230 -60.38930)\n    \n    \n      2\n      2023-04-24T00:41:55.460Z\n      -29.9676\n      -177.8264\n      43.063\n      7.1\n      POINT (-177.82640 -29.96760)\n    \n    \n      3\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n      POINT (98.48390 -0.95890)\n    \n    \n      4\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n      POINT (98.57800 -0.76450)\n    \n  \n\n\n\n\n\n\n\nNo er alt klart for √• starta med plotting. Me lagar eit basekart av verda og plottar jordskjelva opp√• dette.\n\n# bakgrunnskart - data\nworld = gpd.read_file(gpd.datasets.get_path(\"naturalearth_lowres\"))\n\n# plotte bakgrunnskart\nbase = world.plot(color = \"linen\", \n                  edgecolor = \"gray\", \n                  figsize = (15, 8)\n                 )\n\nskjelv_gdf.plot(ax = base, markersize = 2) \n\nplt.title(\"Jordskjelv sterkare enn 5,5 fr√• 1982 - 2023\", fontsize = 18)\nplt.show()\n\n\n\n\n\n\nFor √• f√• fram ulikskapar mellom skjelva kan me plotta punkta slik at dei vert st√∏rre di sterkare skjelva dei representerer er. Skjelva er fr√• 5.5 til 9.1 i styrke. Legg til ei ny kolonne i tabellen for storleik p√• mark√∏r. For at den skal g√• fr√• 1 og oppover, trekk me 4,5 fr√• verdien til mag.\n\nskjelv_gdf[\"mark√∏r\"] = skjelv_gdf[\"mag\"] - 4.5\nskjelv_gdf.head()\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      geometry\n      mark√∏r\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n      POINT (98.53390 -0.78100)\n      2.6\n    \n    \n      1\n      2023-04-24T02:17:56.596Z\n      -60.3893\n      -26.1923\n      10.000\n      5.6\n      POINT (-26.19230 -60.38930)\n      1.1\n    \n    \n      2\n      2023-04-24T00:41:55.460Z\n      -29.9676\n      -177.8264\n      43.063\n      7.1\n      POINT (-177.82640 -29.96760)\n      2.6\n    \n    \n      3\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n      POINT (98.48390 -0.95890)\n      1.2\n    \n    \n      4\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n      POINT (98.57800 -0.76450)\n      1.3\n    \n  \n\n\n\n\nPlottar p√• nytt. Merk at me endrar typen til scatter som gjer at mark√∏rstorleiken f√•r eit anna argument s i staden for markersize. Pr√∏v deg gjerne fram for √• finna ein fin verdi for storleiken. Eg endte opp med 3*skjelv_gdf[\"mark√∏r\"]**4.\n\n# bakgrunnskart\nworld = gpd.read_file(gpd.datasets.get_path(\"naturalearth_lowres\"))\n\nbase = world.plot(color = \"bisque\", \n                  edgecolor = \"gray\", \n                  figsize = (14, 8)\n                 )\n\n# plottar skjelva\nskjelv_gdf.plot(ax = base, \n                kind = \"scatter\", \n                x = \"longitude\", \n                y = \"latitude\",\n                marker = \"o\",\n                color = \"salmon\",\n                s = 3*skjelv_gdf[\"mark√∏r\"]**4, # st√∏rrelse p√• pkt. \n                edgecolor = \"maroon\",\n                alpha = 0.6 # gjennomsiktighet\n               )\n\nplt.title(\"Jordskjelv sterkare enn 5,5 fr√• 1982 - 2023 \\n\", fontsize = 22)\nplt.xlabel(\"Lengdegrad\", fontsize = 16)\nplt.ylabel(\"Breiddegrad\", fontsize = 16)\n#plt.savefig(\"jordskjelv_verda_styrke.png\", dpi = 300) # <-- bruk denne for √• lagra figuren\nplt.show()\n\n\n\n\n\n\n\n\nFor √• f√• betre oversikt kan me zooma inn p√• eit avgrensa omr√•de av jorda. Me kan t.d. sj√• p√• omr√•da rundt Indonesia. Les av omtrentlege lengde- og breddegrader p√• oversiktskartet. Legg avgrensingane inn som eigne variablar, slik at det er lett √• endra dei seinare.\n\n# Avgrensingar for r√•data og kartplotting\nlat_min = -25\nlat_maks = 60\nlong_min = 80\nlong_maks = 170\n\nBruker vidare avgrensingane til √• sortera ut ein eigen tabell med dei aktuelle skjelva.\n\n# lagar ny gdf til avgrensa omr√•de\nomr√•de_skjelv = skjelv_gdf[(skjelv_gdf.latitude > lat_min) \n                           & (skjelv_gdf.latitude < lat_maks)\n                           & (skjelv_gdf.longitude > long_min) \n                           & (skjelv_gdf.longitude < long_maks)\n                          ]\n\nomr√•de_skjelv.shape\n\n(9302, 7)\n\n\nHer ser me at me framleis har 9302 skjelv i tabellen, s√• omlag halvparten av dei 20 000 skjelva er fr√• det avgrensa omr√•det. Tar me ein kikk p√• dei 10 f√∏rste linjene s√• ser me at indeksen ikkje er heilt i orden.\n\nomr√•de_skjelv.head(10)\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      geometry\n      mark√∏r\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n      POINT (98.53390 -0.78100)\n      2.6\n    \n    \n      3\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n      POINT (98.48390 -0.95890)\n      1.2\n    \n    \n      4\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n      POINT (98.57800 -0.76450)\n      1.3\n    \n    \n      5\n      2023-04-22T09:15:54.527Z\n      -5.3425\n      125.6370\n      20.667\n      5.5\n      POINT (125.63700 -5.34250)\n      1.0\n    \n    \n      6\n      2023-04-22T08:23:42.518Z\n      -5.2697\n      125.5950\n      7.270\n      6.0\n      POINT (125.59500 -5.26970)\n      1.5\n    \n    \n      8\n      2023-04-21T10:21:13.739Z\n      2.7929\n      127.0480\n      24.575\n      5.9\n      POINT (127.04800 2.79290)\n      1.4\n    \n    \n      10\n      2023-04-19T09:06:05.200Z\n      -5.9994\n      149.6062\n      55.674\n      6.3\n      POINT (149.60620 -5.99940)\n      1.8\n    \n    \n      12\n      2023-04-18T02:40:53.003Z\n      54.1600\n      159.9190\n      110.846\n      5.6\n      POINT (159.91900 54.16000)\n      1.1\n    \n    \n      13\n      2023-04-17T11:05:55.474Z\n      -4.8912\n      102.9538\n      58.386\n      5.5\n      POINT (102.95380 -4.89120)\n      1.0\n    \n    \n      14\n      2023-04-15T15:07:06.934Z\n      -4.8648\n      102.9744\n      56.688\n      5.5\n      POINT (102.97440 -4.86480)\n      1.0\n    \n  \n\n\n\n\nIkkje at det er veldig viktig no, men om me vil s√• kan me ordna dette lett.\n\nomr√•de_skjelv = omr√•de_skjelv.reset_index(drop=True)\nomr√•de_skjelv.head(10)\n\n\n\n\n\n  \n    \n      \n      time\n      latitude\n      longitude\n      depth\n      mag\n      geometry\n      mark√∏r\n    \n  \n  \n    \n      0\n      2023-04-24T20:00:55.086Z\n      -0.7810\n      98.5339\n      15.462\n      7.1\n      POINT (98.53390 -0.78100)\n      2.6\n    \n    \n      1\n      2023-04-22T21:17:45.986Z\n      -0.9589\n      98.4839\n      10.000\n      5.7\n      POINT (98.48390 -0.95890)\n      1.2\n    \n    \n      2\n      2023-04-22T17:09:45.448Z\n      -0.7645\n      98.5780\n      27.385\n      5.8\n      POINT (98.57800 -0.76450)\n      1.3\n    \n    \n      3\n      2023-04-22T09:15:54.527Z\n      -5.3425\n      125.6370\n      20.667\n      5.5\n      POINT (125.63700 -5.34250)\n      1.0\n    \n    \n      4\n      2023-04-22T08:23:42.518Z\n      -5.2697\n      125.5950\n      7.270\n      6.0\n      POINT (125.59500 -5.26970)\n      1.5\n    \n    \n      5\n      2023-04-21T10:21:13.739Z\n      2.7929\n      127.0480\n      24.575\n      5.9\n      POINT (127.04800 2.79290)\n      1.4\n    \n    \n      6\n      2023-04-19T09:06:05.200Z\n      -5.9994\n      149.6062\n      55.674\n      6.3\n      POINT (149.60620 -5.99940)\n      1.8\n    \n    \n      7\n      2023-04-18T02:40:53.003Z\n      54.1600\n      159.9190\n      110.846\n      5.6\n      POINT (159.91900 54.16000)\n      1.1\n    \n    \n      8\n      2023-04-17T11:05:55.474Z\n      -4.8912\n      102.9538\n      58.386\n      5.5\n      POINT (102.95380 -4.89120)\n      1.0\n    \n    \n      9\n      2023-04-15T15:07:06.934Z\n      -4.8648\n      102.9744\n      56.688\n      5.5\n      POINT (102.97440 -4.86480)\n      1.0\n    \n  \n\n\n\n\n\n\nNo kan me plotta det avgrensa omr√•det. Bruker variablane med grensene for √• tilpassa bakgrunnskartet.\n\nbase = world.plot(color=\"lightgrey\",\n                  edgecolor=\"black\", \n                  figsize=(8,10),\n                 )\n\nbase.set_ylim([lat_min, lat_maks])\nbase.set_xlim([long_min, long_maks])\n\nomr√•de_skjelv.plot(ax = base, \n                   color = \"red\",\n                   markersize = 10\n                  )\n\nplt.show()\n\n\n\n\nP√• denne figuren ser me at det er nokre omr√•de der skjelva dekker breiare linjer enn ellers. Pr√∏ver √• f√• fram kor djupe dei ulike skjelva er. Me deler inn datamaterialet i grunne, middels og djupe skjelv, med 30 km og 300 km som grenser mellom dei tre kategoriane.\n\nomr√•de_djup = omr√•de_skjelv[(omr√•de_skjelv.depth > 300)]\nomr√•de_middels = omr√•de_skjelv[(omr√•de_skjelv.depth <= 300)\n                               & (omr√•de_skjelv.depth > 30)]\nomr√•de_grunn = omr√•de_skjelv[(omr√•de_skjelv.depth <= 30)]\n\nDesse nye gdf-ane kan me plotta p√• oversiktskart over regionen:\n\n# bakgrunnskart\nbase = world.plot(color=\"linen\",\n                  edgecolor=\"dimgray\", \n                  figsize=(9,9),\n                 )\n\n# avgrensing (til omr√•det)\nbase.set_ylim([lat_min, lat_maks])\nbase.set_xlim([long_min, long_maks])\n\n# plotte skjelva\nomr√•de_djup.plot(ax = base, color=\"dodgerblue\", markersize=10)\nomr√•de_middels.plot(ax = base, color=\"gold\", markersize=10)\nomr√•de_grunn.plot(ax = base, color=\"red\", markersize=10)\n\n# pynt\nplt.title(\"\\nJordskjelv vest i Stillehavet\\n\", fontsize = 22)\nplt.xlabel(\"Lengdegrad\", fontsize = 16)\nplt.ylabel(\"Breiddegrad\", fontsize = 16)\nplt.legend([\"djupe ($d > 300 km$)\", \n           \"middels ($30 km < d \\leq 300 km$)\",\n           \"grunne ($d \\leq 30 km$)\"\n           ])\nplt.savefig(\"jordskjelv_stillehavet_djupne.png\", dpi=200, bbox_inches=\"tight\")\nplt.show()\n\n\n\n\nLegg merke til \\(\\LaTeX\\)-formateringa middels ($30 km < d \\leq 300 km$ i teiknforklaringa.\n\n\n\n\n\n\nTips\n\n\n\nFigurar som dei me har laga her, i sj√∏lvvalde omr√•de, er supert utgangspunkt for vurdering (videopresentasjon, fagsamtale e.l.). D√• kan elevane forklara kva dei ulike figurane viser, kvifor dei ser ut som dei gjer, og vidare gjera greie for aktuelle fagomgrep og prosessar knytt til dette.\n\nKva m√∏nster ser du i styrken p√• skjelva? Kva kan vera √•rsaken til det?\nKva m√∏nster ser du i djupna p√• skjelva? Kva fortel det oss? Er det samanhengar mellom dei to figurane?"
  },
  {
    "objectID": "series-lf.html",
    "href": "series-lf.html",
    "title": "L√∏ysingsforslag matteeksamen",
    "section": "",
    "text": "Eksamen V22 S1\n\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2023\n\n\n7 minutt\n\n\n\n\n\n\n\n\nEksamen H22 S1\n\n\n\n\n\n\n\n\n\n\n\n\nMar 27, 2023\n\n\n8 minutt\n\n\n\n\n\n\nIngen passande treff"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Heim",
    "section": "",
    "text": "L√∏ysingsforslag eksamen\n\nL√∏ysingsforslag\nHer er nokre l√∏ysingsforslag til ulike eksamenar p√• vgs. P√• del pr√∏ver eg √• nytta Python i st√∏rst mogleg grad üêç\n\n\n\nInnlegg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEksamen V22 S1\n\n\n7 minutt\n\n\n\nS1\n\n\nV22\n\n\neksamen\n\n\n\n\n\n\n\nMay 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJordskjelvpython\n\n\n5 minutt\n\n\n\nmodellering\n\n\nprogrammering\n\n\ntips\n\n\ngeofag\n\n\n\n\n\n\n\nApr 25, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEksamen H22 S1\n\n\n8 minutt\n\n\n\nS1\n\n\nH22\n\n\neksamen\n\n\n\n\n\n\n\nMar 27, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSamansett simulering i S2\n\n\n2 minutt\n\n\n\nprogrammering\n\n\ns-matte\n\n\nsimulering\n\n\neksamensoppg√•ve\n\n\ntips\n\n\n\n\n\n\n\nMar 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrunnleggjande simulering i NumPy\n\n\n3 minutt\n\n\n\nprogrammering\n\n\ns-matte\n\n\nsimulering\n\n\ntips\n\n\n\n\n\n\n\nFeb 9, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHydrologiprogrammering\n\n\n4 minutt\n\n\n\nmodellering\n\n\nprogrammering\n\n\ntips\n\n\ngeofag\n\n\n\n\n\n\n\nFeb 2, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZotero - kva, kvifor, korleis?\n\n\n4 minutt\n\n\n\nverkt√∏y\n\n\nkjelder\n\n\ntips\n\n\n\n\n\n\n\nJan 27, 2023\n\n\n\n\n\n\n\n\nIngen passande treff"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Om meg",
    "section": "",
    "text": "Torodd her üëã Eg jobbar som lektor i vidareg√•ande skule. Underviser i matematikk, geofag og geografi. Interessert i teknologibruk i skulen, og spesielt programmering (s√• interessert at eg har skrive masteroppg√•ve i emnet üòÖ)\nJobbar stadig med √• utvikla den profesjonsfaglege digitale kompetansen (PfDK), s√• denne bloggen er ein del av dette‚Ä¶ Kjekt √• b√•de f√• tenkt litt p√• korleis programmering kan brukast i skulen, og l√¶ra meg noko nytt (Quarto) üòä\nP√• denne bloggen kjem eg til √• dela nokre digitale tips og triks samt litt tankar og erfaringar knytt til programmering i matematikk og geofag üåã"
  }
]